#!/usr/bin/env bash
set -eEuo pipefail

# Error codes
EX_USAGE=101          # CLI misuse / invalid flags
EX_NO_INPUT=102       # File not found
EX_UNAVAILABLE=103    # Dependency missing / unusable
EX_NO_DATA=104        # No/empty/invalid front-matter
EX_NO_RESULT=105      # Parameter not found / empty (soft by default)
EX_UNSUPPORTED=106    # Unsupported type (e.g., map)
EX_INTERNAL=198       # Internal error
EX_UNKNOWN=199        # Unexpected error

# Internal error codes (not exposed to users)
EX_PARAM_NOT_FOUND=1
EX_PARAM_IS_MAP=2
EX_PARAM_EMPTY_ARRAY=3
EX_INVALID_FRONTMATTER=4

#Usage string
COMMAND_NAME="$(basename "$0")"
USAGE="Usage: $COMMAND_NAME [-p|--parameter <name>]... [-0|--print0] [--value-only] [-h|--help] [-v|--verbose <level>] [-q|--quiet] [--strict] [--] <file>"

# Helpers
_verbose_level=1

debug() { if (( _verbose_level >= 3 )); then printf '[DEBUG] [%s] %s\n' "$COMMAND_NAME" "$*" >&2; fi; }
log()   { if (( _verbose_level >= 2 )); then printf '[INFO] [%s] %s\n' "$COMMAND_NAME" "$*" >&2; fi; }
warn()  { if (( _verbose_level >= 1 )); then printf '[WARN] [%s] %s\n' "$COMMAND_NAME" "$*" >&2; fi; }
error() { printf '[ERROR] [%s] %s\n' "$COMMAND_NAME" "$*" >&2; }
is_on() { [[ "$1" == "on" ]]; }

die() {
    local -r _message="${1:-"Unknown error"}"
    local -r _ret="${2:-${EX_UNKNOWN}}"
    if is_on "${_PRINT_USAGE:-no}" && (( _arg_verbose > 0 )); then "$USAGE" >&2; fi
    local _err_tag=""
    case "$_ret" in
        "$EX_USAGE") _err_tag="[E.USAGE]" ;;
        "$EX_NO_INPUT") _err_tag="[E.NO_INPUT]" ;;
        "$EX_UNAVAILABLE") _err_tag="[E.UNAVAILABLE]" ;;
        "$EX_NO_DATA") _err_tag="[E.NO_DATA]" ;;
        "$EX_NO_RESULT") _err_tag="[E.NO_RESULT]" ;;
        "$EX_UNSUPPORTED") _err_tag="[E.UNSUPPORTED]" ;;
        "$EX_INTERNAL") _err_tag="[E.INTERNAL]" ;;
        "$EX_UNKNOWN") _err_tag="[E.UNKNOWN]" ;;
        *) _err_tag="[E.CODE_${_ret}]" ;;
    esac
    error "$_err_tag $_message"
    exit "$_ret"
}

trap 'die "(exit $?): ${BASH_SOURCE[1]:-${BASH_SOURCE[0]}}:${LINENO} in ${FUNCNAME[1]:-main}" ${EX_UNKNOWN}' ERR

print_help() {
    cat <<USAGE
Extracts parameters from YAML frontmatter in a file.
${USAGE}

Parameters:
    <file>                  Path to the file containing YAML frontmatter.
    -p, --parameter <name>  Specify a parameter to extract from the frontmatter.
                            Can be specified multiple times.
    -0, --print0            Output results separated by null characters instead of newlines.
    -v, --verbose <level>   Set verbosity level (0 or 'quiet', 1 or 'normal' (default), 2 or 'verbose', 3 or 'debug')
    -q, --quiet             Equivalent to -v 0
    -h, --help              Display this help message and exit.
    --strict                Exit with an error instead of warning.
    --value-only            Output only the values of the specified parameters, without parameter names.
    --                      End of options

Returns:
    - If --parameter is specified:
        - without the --value-only option: prints each parameter and its value in the format "<parameter> <value>", one per line or null-separated if --print0 is used.
        - with the --value-only option: prints only the values, one per line or null-separated if --print0 is used.
    - If no --parameter is specified: prints all parameter names in the frontmatter, one per line or null-separated if --print0 is used.

Examples:
    frontmatter-parser.sh example.md --parameter title --parameter author
    frontmatter-parser.sh example.md

Dependencies:
    - yq    A command-line YAML processor (https://github.com/mikefarah/yq)

Error Codes:
    ${EX_USAGE}         Command line usage error (invalid flags, missing arguments)
    ${EX_NO_INPUT}       Input file not found
    ${EX_UNAVAILABLE}   Dependency missing or unusable (e.g., yq not installed)
    ${EX_NO_DATA}        No/empty/invalid front-matter
    ${EX_NO_RESULT}      Parameter not found or empty (soft by default)
    ${EX_UNSUPPORTED}   Unsupported type (e.g., map)
    ${EX_INTERNAL}      Internal error
    ${EX_UNKNOWN}       Unexpected error
USAGE
}

_arg_verbose=0
_arg_file_path=""
_arg_print0="off"
_arg_value_only="off"
_arg_strict="off"
_arg_parameters=()
_print_all_parameters="off"
_has_v4_yq="on"

check_dependencies() {
    if ! command -v yq &>/dev/null; then
        die "Dependency 'yq' not found. Please install it and ensure it's in your PATH." $EX_UNAVAILABLE
    fi
}

# -- parse arguments --

parse_commandline() {
    local _key
    local -a _positionals=()
    while [[ $# -gt 0 ]]; do
        _key="$1"
        case "$_key" in
        -p|--parameter)
            shift
            if [[ -z "${1:-}" ]]; then
                _PRINT_USAGE="on" die "--parameter requires a value." $EX_USAGE
            fi
            _arg_parameters+=("$1")
            shift
            ;;
        --parameter=*)
            local -r _value="${_key##--parameter=}"
            if [[ -z "$_value" ]]; then
                _PRINT_USAGE="on" die "--parameter requires a value." $EX_USAGE
            fi
            _arg_parameters+=("$_value")
            shift
            ;;
        -h|--help)
            print_help
            exit 0
            ;;
        -0|--print0)
            _arg_print0="on"
            shift
            ;;
        --value-only)
            _arg_value_only="on"
            shift
            ;;
        -v | --verbose)
            shift
            if [[ $# -lt 1 ]]; then
                _PRINT_HELP="on" die "--verbose requires a value." 1
            fi
            _arg_verbose="$1"
            shift
            ;;
        -v=* | --verbose=*)
            _arg_verbose="${_key##*=}"
            shift
            ;;
        -q | --quiet)
            _arg_verbose=0
            shift
            ;;
        --strict)
            _arg_strict="on"
            shift
            ;;
        --) # End of all options
            shift
            while [[ $# -gt 0 ]]; do
                _positionals+=("$1")
                shift
            done
            ;;
        -*) # Unknown option
            _PRINT_USAGE="on" die "Unknown option '$1'." $EX_USAGE
            ;;
        *) # Positional argument
            _positionals+=("$1")
            shift
            ;;
        esac
    done

    if [[ ${#_positionals[@]} -lt 1 ]]; then
        _PRINT_USAGE="on" die "No input file specified." $EX_USAGE
    elif [[ ${#_positionals[@]} -gt 1 ]]; then
        _PRINT_USAGE="on" die "Multiple input files specified. Please provide only one." $EX_USAGE
    fi

    if [[ ${#_arg_parameters[@]} -eq 0 ]]; then
        _print_all_parameters="on"
    fi

    _arg_file_path="${_positionals[0]}"
}

validate_arguments() {
    if [[ -z "$_arg_file_path" ]]; then
        _PRINT_USAGE="on" die "No input file specified." $EX_USAGE
    fi
    if [[ ! -f "$_arg_file_path" ]]; then
        die "File '$_arg_file_path' not found." $EX_NO_INPUT
    fi

    case "$_arg_verbose" in
        0 | quiet) _verbose_level=0 ;;
        1 | normal) _verbose_level=1 ;;
        2 | verbose) _verbose_level=2 ;;
        3 | debug) _verbose_level=3 ;;
        *)
            _PRINT_HELP="on" die "Invalid value for --verbose: '$_arg_verbose'. Must be one of: 0 or 'quiet', 1 or 'normal', 2 or 'verbose', 3 or 'debug'." $EX_USAGE
            ;;
    esac

    # Internal errors
    case "$_arg_print0" in
        on|off) ;;
        *) die "Invalid value for --print0: '$_arg_print0'. Allowed values are 'on' or 'off'." $EX_INTERNAL ;;
    esac
    case "$_arg_value_only" in
        on|off) ;;
        *) die "Invalid value for --value-only: '$_arg_value_only'. Allowed values are 'on' or 'off'." $EX_INTERNAL ;;
    esac
}

# Function to get the installed yq version
# Returns the full version by default, or just the major version if the first argument is "true"
get_yq_version() {
    # Works for: "yq (https://...) version 4.44.1", "yq version v4.30.6", "yq 3.4.1"
    local _version _major
    _version="$(yq --version 2>/dev/null || yq -V 2>/dev/null || true)"
    _version="${_version##*[[:space:]]}" # Trim text before the last space
    _version="${_version#v}"             # Remove leading 'v' if present
    _major="${_version%%.*}"             # Extract major version

    if [[ "$_major" -lt 4 ]]; then
        warn "yq version 4 or higher is recommended. Found version ${_version}."
        _has_v4_yq="off"
    fi
}

extract_frontmatter() {
    local -r _file="${1?$(die "No file provided to extract_frontmatter" $EX_INTERNAL)}"
    local _out

    if is_on $_has_v4_yq && _out="$(yq --front-matter extract --no-doc "$_file" 2>/dev/null)"; then
        debug "Extracted frontmatter using yq v4+ from '$_file'."
        # Check if the output is a valid YAML mapping
        if ! printf '%s' "$_out" | yq --output-format=yaml 'type =="!!map"' &>/dev/null; then
            return $EX_INVALID_FRONTMATTER
        fi
    else
        debug "Attempting manual frontmatter extraction from '$_file'..."
        # Only attempt manual extraction if the file starts with '---' (ignoring leading/trailing spaces and Windows line endings)
        if head -n 1 "$_file" | tr -d '\r' | grep -qE '^[[:space:]]*---[[:space:]]*$'; then
            debug "File '$_file' starts with '---', attempting manual extraction..."
            # Start on line 1 to ensure we only capture frontmatter at the top of the file
            # And drop delimiter lines in the result
            _out="$(sed -n '1,/^[[:space:]]*---[[:space:]]*$/p' "$_file" | sed '1d;$d')"
        fi
    fi

    # Don't trim _out, as leading/trailing newlines (and whitespaces) may be significant in YAML
    printf '%s' "$_out"
}

get_parameter_with_pick() {
    local -r _param="${1:?$(die "No parameter name provided" $EX_INTERNAL)}"
    local -r _frontmatter="${2:?$(die "No frontmatter provided" $EX_INTERNAL)}"
    local -n _pick_ref="${3:?$(die "No result array name provided" $EX_INTERNAL)}"

    local _value
    if ! _value=$(echo "$_frontmatter" | yq --unwrapScalar --exit-status ".\"$_param\"" 2>/dev/null); then
        return $EX_PARAM_NOT_FOUND

    fi
    if printf '%s' "$_value" | yq --exit-status 'type == "!!map"' &>/dev/null; then # Command fails if not a map
        return $EX_PARAM_IS_MAP
    fi

    local _is_array="off"
    if printf '%s' "$_value" | yq --exit-status 'type == "!!seq"' &>/dev/null; then # Command fails if not an array
        _is_array="on"
    fi

    if is_on "$_is_array"; then
        if is_on "$_arg_print0"; then
            local -a _items
            readarray -d '' -t _items < <(printf '%s' "$_value" | yq --unwrapScalar --nul-output '.[]')
            if [[ ${#_items[@]} -eq 0 ]]; then
                return $EX_PARAM_EMPTY_ARRAY
            fi
            _pick_ref+=("${_items[@]}")
        else
            # convert each item to string, then join with commas
            _pick_ref+=("$(printf '%s' "$_value" | yq --output-format=json '. | map(tostring) | join(",")')")
        fi
    else
        _value="$(printf '%s' "$_value" | yq --output-format=json '.')"
        _pick_ref+=("$_value")
    fi
}

get_parameter_fallback() {
    local -r _param="${1:?$(die "No parameter name provided" $EX_INTERNAL)}"
    local -r _frontmatter="${2:?$(die "No frontmatter provided" $EX_INTERNAL)}"
    local -n _fallback_ref="${3:?$(die "No result array name provided" $EX_INTERNAL)}"

    local _value
    if ! _value=$(echo "$_frontmatter" | yq --compact-output --raw-output --exit-status ".\"$_param\"" 2>/dev/null); then
        return $EX_PARAM_NOT_FOUND
    fi

    _fallback_ref+=("$_value")
}

get_parameter() {
    local -r _param="${1:?$(die "No parameter name provided" $EX_INTERNAL)}"
    local -r _frontmatter=$2
    local -n _parameter_ref="${3:?$(die "No result array name provided" $EX_INTERNAL)}"

    if [[ -z "$_frontmatter" ]]; then
        die "No frontmatter provided ('$_frontmatter') to get_parameter" $EX_INTERNAL
    fi

    if is_on "$_has_v4_yq"; then
        get_parameter_with_pick "$_param" "$_frontmatter" _parameter_ref
        return $?
    else
        get_parameter_fallback "$_param" "$_frontmatter" _parameter_ref
        return $?
    fi
}

main() {
    check_dependencies
    get_yq_version
    parse_commandline "$@"
    validate_arguments

    debug "Extracting frontmatter from '$_arg_file_path'..."
    local _frontmatter
    if ! _frontmatter="$(extract_frontmatter "$_arg_file_path")"; then
        local _err=$?
        case $_err in
            0) ;; # No error
            "$EX_INVALID_FRONTMATTER")
                is_on "$_arg_strict" && die "No valid YAML frontmatter found at the top of $_arg_file_path" $EX_NO_DATA
                warn "No valid YAML frontmatter found at the top of $_arg_file_path"
                return 0
                ;;
            *)
                die "Unknown error while extracting frontmatter from '$_arg_file_path'." $EX_UNKNOWN
                ;;
        esac
    fi

    if [[ -z "$_frontmatter" ]]; then
        is_on "$_arg_strict" && die "No frontmatter found in '$_arg_file_path'." $EX_NO_DATA
        warn "No frontmatter found in '$_arg_file_path'."
        return 0
    fi
    debug "Frontmatter successfully extracted from '$_arg_file_path'"

    local -a _found_parameters=()
    if is_on "$_print_all_parameters"; then
        local _all_params
        log "No parameters specified, listing all parameters in frontmatter..."
        # TODO Error handling if yq fails
        if is_on "$_arg_print0"; then
            local -a _keys
            readarray -d '' -t _keys < <(echo "$_frontmatter" | yq --unwrapScalar --nul-output "keys | .[]")
            if [[ ${#_keys[@]} -eq 0 ]]; then
                is_on "$_arg_strict" && die "No parameters found in frontmatter." $EX_NO_DATA
                warn "No parameters found in frontmatter."
                printf ''
            else
                debug "Found ${#_keys[@]} parameters in frontmatter (${_keys[*]})."
                printf '%s\0' "${_keys[@]}"
            fi
        else
            printf '%s\n' "$(echo "$_frontmatter" | yq -r "keys | .[]")"
        fi
    else
        log "Retrieving specified parameters from frontmatter..."
        local _param
        for _param in "${_arg_parameters[@]}"; do
            log "Retrieving parameter '$_param'..."
            local -a _param_return_array=()
            if ! get_parameter "$_param" "$_frontmatter" _param_return_array; then
                local _err=$?
                case $_err in
                    0) ;; # No error
                    "$EX_PARAM_NOT_FOUND")
                        is_on "$_arg_strict" && die "Parameter '$_param' not found in '$_arg_file_path' frontmatter." $EX_NO_RESULT
                        warn "Parameter '$_param' not found in '$_arg_file_path' frontmatter."
                        continue
                        ;;
                    "$EX_PARAM_IS_MAP")
                        is_on "$_arg_strict" && die "Parameter '$_param' in '$_arg_file_path' frontmatter is a map, which is not supported." $EX_UNSUPPORTED
                        warn "Parameter '$_param' in '$_arg_file_path' frontmatter is a map, which is not supported."
                        continue
                        ;;
                    "$EX_PARAM_EMPTY_ARRAY")
                        is_on "$_arg_strict" && die "Parameter '$_param' in '$_arg_file_path' frontmatter is an empty array." $EX_NO_RESULT
                        warn "Parameter '$_param' in '$_arg_file_path' frontmatter is an empty array."
                        continue
                        ;;
                    *)
                        die "Unknown error while retrieving parameter '$_param' in '$_arg_file_path' frontmatter (error code $_err)." $EX_UNKNOWN
                        ;;
                esac
            fi

            if [[ ${#_param_return_array[@]} -eq 0 ]]; then
                is_on "$_arg_strict" && die "Parameter '$_param' not found in '$_arg_file_path' frontmatter." $EX_NO_RESULT
                warn "Failed to get parameter '$_param' in '$_arg_file_path' frontmatter."
                continue
            fi

            log "Parameter '$_param' found and has ${#_param_return_array[@]} value(s)."

            if is_on "$_arg_print0"; then
                if ! is_on "$_arg_value_only"; then
                    _found_parameters+=("$_param")
                fi
                _found_parameters+=("${_param_return_array[@]}")
                continue
            else
                local _value
                _value="$(printf '%s\t' "${_param_return_array[@]}")"
                _value="${_value%$'\t'}" # Remove trailing tab
                if is_on "$_arg_value_only"; then
                    _found_parameters+=("$_value")
                else
                    _found_parameters+=("$(printf '%s\t%s' "$_param" "$_value")")
                fi
            fi
        done

        # -- output results --
        if is_on "$_arg_print0"; then
            printf '%s\0' "${_found_parameters[@]}"
        else
            printf '%s\n' "${_found_parameters[@]}"
        fi
    fi
}
main "$@"
