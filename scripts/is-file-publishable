#!/usr/bin/env bash
set -eEuo pipefail

# Error codes
EX_USAGE=101          # CLI misuse / invalid flags
EX_NO_INPUT=102       # File not found
EX_DEP_ISSUE=103      # Dependency missing / unusable
EX_FRONTMATTER=104    # No/empty/invalid front-matter
EX_INTERNAL=198       # Internal error
EX_UNKNOWN=199        # Unexpected error

# Usage string
COMMAND_NAME="$(basename "$0")"

USAGE="Usage: $COMMAND_NAME [--ignore-publish-state] [--alias-mode <arg>] [-h|--help] [-v|--verbose-level <level>] [--quiet] [-vv|--very-verbose] [--] <file>"

_verbose_level=1

debug() { if (( _verbose_level >= 3 )); then printf '[DEBUG] [%s] %s\n' "$COMMAND_NAME" "$*" >&2; fi; }
log()   { if (( _verbose_level >= 2 )); then printf '[INFO] [%s] %s\n' "$COMMAND_NAME" "$*" >&2; fi; }
warn()  { if (( _verbose_level >= 1 )); then printf '[WARN] [%s] %s\n' "$COMMAND_NAME" "$*" >&2; fi; }
error() { printf '[ERROR] [%s] %s\n' "$COMMAND_NAME" "$*" >&2; }
is_on() { [[ "$1" == "on" ]]; }

die() {
    local -r _message="${1:-"Unknown error"}"
    local -r _ret="${2:-${EX_UNKNOWN}}"
    if is_on "${_PRINT_USAGE:-no}" && (( _verbose_level > 0 )); then "$USAGE" >&2; fi
    local _err_tag=""
    case "$_ret" in
        "$EX_USAGE") _err_tag="[USAGE]" ;;
        "$EX_NO_INPUT") _err_tag="[NO_INPUT]" ;;
        "$EX_DEP_ISSUE") _err_tag="[DEP_ISSUE]" ;;
        "$EX_FRONTMATTER") _err_tag="[FRONTMATTER]" ;;
        "$EX_INTERNAL") _err_tag="[INTERNAL]" ;;
        "$EX_UNKNOWN") _err_tag="[UNKNOWN]" ;;
        *) _err_tag="[CODE_${_ret}]" ;;
    esac
    error "$_err_tag $_message"
    exit "$_ret"
}

trap 'die "(exit $?): ${BASH_SOURCE[1]:-${BASH_SOURCE[0]}}:${LINENO} in ${FUNCNAME[1]:-main}" ${EX_UNKNOWN}' ERR

print_help() {
    cat <<USAGE
Check if a file is publishable based on front-matter options.
${USAGE}

Arguments:
    <file>                      File to check (required)
    --ignore-publish-state      Ignore 'publish' option in front-matter (default: false)
    --alias-mode                Check for 'aliases' option if 'slug' or 'url' is set in file front-matter ('ignore', 'warn', 'error'. Default: 'ignore')
    -v, --verbose-level <level> Set verbosity level (0 or 'quiet', 1 or 'normal' (default), 2 or 'debug', 3 or 'verbose')
    --very-verbose, -vv         Very verbose mode (same as -v 3)
    --quiet                     Quiet mode (same as -v 0)
    -h, --help                  Display this help message and exit.
    --                          End of options

Examples:
    is-file-publishable note.md
    is-file-publishable --ignore-publish-state note.md
    is-file-publishable --alias-mode warn note.md

Dependencies:
    - frontmatter-parser
    - realpath
    - Bash version 4.3 or higher

Notes:
    Supported alias formats are:
      - Without leading slash: my-note
      - With leading slash: /my-note
    The alias must not include file extensions.

Error codes:
    ${EX_USAGE}         Command line usage error (invalid flags, missing arguments)
    ${EX_NO_INPUT}      Input file not found
    ${EX_DEP_ISSUE}     Dependency missing or unusable (e.g., yq not installed)
    ${EX_FRONTMATTER}   No/empty/invalid front-matter
    ${EX_INTERNAL}      Internal error
    ${EX_UNKNOWN}       Unexpected error
USAGE
}

_arg_verbose=0
_arg_ignore_publish_state="off"
_arg_alias_mode="ignore"
_arg_file=""
_abs_file=""

parse_commandline() {
    local _key
    local -a _positionals=()
    while [[ $# -gt 0 ]]; do
        _key="$1"
        case "$_key" in
        --ignore-publish-state)
            _arg_ignore_publish_state="on"
            shift
            ;;
        --alias-mode)
            shift
            if [[ $# -lt 1 ]]; then
                _PRINT_USAGE="on" die "--alias-mode requires a value." $EX_USAGE
            fi
            _arg_alias_mode="$1"
            shift
            ;;
        --alias-mode=*)
            _arg_alias_mode="${_key##--alias-mode=}"
            shift
            ;;
        -h | --help)
            print_help
            exit 0
            ;;
        -v | --verbose-level)
            shift
            if [[ $# -lt 1 ]]; then
                _PRINT_USAGE="on" die "--verbose-level requires a value." $EX_USAGE
            fi
            _arg_verbose="$1"
            shift
            ;;
        -v=* | --verbose-level=*)
            _arg_verbose="${_key##*=}"
            shift
            ;;
        --quiet)
            _arg_verbose=0
            shift
            ;;
        --very-verbose | -vv)
            _arg_verbose=3
            shift
            ;;
        --)
            # End of options
            shift
            while [[ $# -gt 0 ]]; do
                _positionals+=("$1")
                shift
            done
            ;;
        -*)
            # Unknown option
            _PRINT_USAGE="on" die "Unknown option '$1'." $EX_USAGE
            ;;
        *)
            _positionals+=("$1")
            shift
            ;;
        esac
    done

    local -r _positionals_count=${#_positionals[@]}
    if [[ "${_positionals_count}" -lt 1 ]]; then
        _PRINT_USAGE="on" die "No positional arguments provided." $EX_USAGE
    fi
    if [[ "${_positionals_count}" -gt 1 ]]; then
        _PRINT_USAGE="on" die "Too many positional arguments provided (expected 1, got $_positionals_count)." $EX_USAGE
    fi

    _arg_file="${_positionals[0]}"
}

check_dependencies() {
    if ! command -v frontmatter-parser &>/dev/null; then
        die "Error: Could not find frontmatter-parser in PATH." $EX_DEP_ISSUE
    fi
    if ! command -v realpath &>/dev/null; then
        die "Error: Could not find realpath in PATH." $EX_DEP_ISSUE
    fi
    if (( BASH_VERSINFO[0] < 4 || ( BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 3 ) )); then
        die "Bash version 4.3 or higher is required. Current version is ${BASH_VERSION}." $EX_DEP_ISSUE
    fi
}

validate_arguments() {
    if ! _abs_file=$(realpath "$_arg_file" 2>/dev/null); then
        die "Error: Could not resolve path for file '$_arg_file'." $EX_NO_INPUT
    fi

    case "$_arg_alias_mode" in
        ignore | warn | error) ;;
        *) die "Invalid value for --alias-mode: '$_arg_alias_mode'. Allowed values are 'ignore', 'warn' or 'error'." $EX_USAGE ;;
    esac

    case "$_arg_verbose" in
        0 | quiet) 
            if [[ ${_arg_alias_mode} == "warn" ]]; then
                _verbose_level=1
                warn "Warning: --alias-mode 'warn' is set but verbosity level is 'quiet'. Warnings would not be shown. Setting verbosity level to 'normal'."
            else
                _verbose_level=0
            fi
            ;;
        1 | normal) _verbose_level=1 ;;
        2 | debug) _verbose_level=2 ;;
        3 | verbose) _verbose_level=3 ;;
        *)
            _PRINT_USAGE="on" die "Invalid value for --verbose: '$_arg_verbose'. Must be one of: 0 or 'quiet', 1 or 'normal', 2 or 'debug', 3 or 'verbose'." $EX_USAGE
            ;;
    esac

    # Internal errors
    case "$_arg_ignore_publish_state" in
        on | off) ;;
        *) die "Invalid value for --ignore-publish-state: '$_arg_ignore_publish_state'. Allowed values are 'on' or 'off'." $EX_INTERNAL ;;
    esac

    if [[ ${_arg_alias_mode} == "warn" && ${_verbose_level} -eq 0 ]]; then
        die "Warning mode with incompatible verbosity level 'quiet'." $EX_INTERNAL
    fi
}

is_publishable() {
    local -r _file="${1?Missing file argument}"
    local -r _ignore_publish_state="${2?Missing ignore publish state argument}"
    local _value
    if ! is_on "$_ignore_publish_state" && _value=$(frontmatter-parser --quiet --parameter "publish" --value-only -- "$_file"); then
        debug "File '$_file' has 'publish' set to '$_value'."
        # Only publish if true (so false, null, empty or any other value means not publishable)
        if [[ "$_value" == "true" ]]; then
            return 0
        else
            return 1
        fi
    else
        debug "Skipping publish state check for file '$_file' because --ignore-publish-state is set to 'on'."
        return 0
    fi
}

check_valid_aliases() {
    local -r _file="${1?Missing file argument}"
    local -r _alias_mode="${2?Missing alias mode argument}"

    if [[ "$_alias_mode" == "ignore" ]]; then
        debug "Not checking aliases for file '$_file' because --alias-mode is set to 'ignore'."
        return 0
    fi

    local _slug _url
    _slug=$(frontmatter-parser --quiet --parameter "slug" --value-only -- "$_file" || echo "")
    _url=$(frontmatter-parser --quiet --parameter "url" --value-only -- "$_file" || echo "")

    # Skip if no slug or url
    if [[ -z "$_slug" && -z "$_url" ]]; then
        debug "Not checking aliases for file '$_file' because it has no 'slug' or 'url' set."
        return 0
    fi

    local -a _aliases=()
    readarray -d '' -t _aliases < <(frontmatter-parser --quiet --parameter "aliases" --value-only --print0 -- "$_file")
    if [[ "${#_aliases[@]}" -eq 0 ]]; then
        debug "File '$_file' has 'slug' or 'url' set but no 'aliases' option."
        case "$_alias_mode" in
        warn)
            warn "File '$_file' has 'slug' or 'url' set but no 'aliases' option."
            return 0
            ;;
        error)
            die "Error: File '$_file' has 'slug' or 'url' set but no 'aliases' option." $EX_FRONTMATTER
            ;;
        esac
    fi

    # Remove leading slash and extension from filename
    local _clean_file_name
    _clean_file_name="${_file#/}"
    _clean_file_name="${_clean_file_name%.*}"

    local _found_alias="false"
    local _alias
    for _alias in "${_aliases[@]}"; do
        # Check if alias matches cleaned filename (allowing leading slash in alias)
        if [[ "${_alias#/}" == "${_clean_file_name}" ]]; then
            _found_alias="true"
            break
        fi
    done

    if [[ "$_found_alias" == "false" ]]; then
        case "$_alias_mode" in
        warn)
            warn "File '$_file' has 'slug' or 'url' set but its filename '$_clean_file_name' is not in 'aliases'."
            ;;
        skip-file)
            log "Skipping file '$_file' because it has 'slug' or 'url' set but its filename '$_clean_file_name' is not in 'aliases'."
            return 1
            ;;
        error)
            die "Error: File '$_file' has 'slug' or 'url' set but its filename '$_clean_file_name' is not in 'aliases'." $EX_FRONTMATTER
            ;;
        esac
    fi
}

main() {
    # Validation and parsing
    check_dependencies
    parse_commandline "$@"
    validate_arguments

    if !(is_publishable "$_abs_file" "$_arg_ignore_publish_state" && check_valid_aliases "$_abs_file" "$_arg_alias_mode"); then
        log "File '$_abs_file' is not publishable."
        exit 1
    fi
    debug "File '$_abs_file' is publishable."
}
main "$@"
