#!/usr/bin/env bash
set -eEuo pipefail

_arg_verbose=1

debug() { if (( _arg_verbose >= 3 )); then printf '[DEBUG] %s\n' "$*" >&2; fi; }
log()   { if (( _arg_verbose >= 2 )); then printf '%s\n' "$*" >&2; fi; }
warn()  { if (( _arg_verbose >= 1 )); then printf '[WARN] %s\n' "$*" >&2; fi; }
error() { printf '[ERROR] %s\n' "$*" >&2; }
is_on() { [[ "$1" == "on" ]]; }

die() {
    local _ret="${2:-1}"
    if is_on "${_PRINT_HELP:-no}" && (( _arg_verbose > 0 )); then print_help >&2; fi
    error "$1"
    exit "$_ret"
}

trap 'die "Error (exit $?): ${BASH_SOURCE[1]}:${BASH_LINENO[0]} in ${FUNCNAME[1]-main}" $?' ERR

print_help() {
    cat <<'USAGE'
Check if a file is publishable based on front-matter options.
Usage: get-files-to-publish [--ignore-publish-state] [--alias-mode <arg>] [-h|--help] [-v|--verbose <level>] [--quiet] [--] <file>

Arguments:
    <file>                  File to check (required)
    --ignore-publish-state  Ignore 'publish' option in front-matter (default: false)
    --alias-mode            Check for 'aliases' option if 'slug' or 'url' is set in file front-matter ('ignore', 'warn', 'error'. Default: 'ignore')
    -v, --verbose <level>   Set verbosity level (0 or 'quiet', 1 or 'normal' (default), 2 or 'verbose', 3 or 'debug')
    --quiet                 Quiet mode (same as -v 0)
    -h, --help              Display this help message and exit.
    --                      End of options

Examples:
    is-file-publishable note.md
    is-file-publishable --ignore-publish-state note.md
    is-file-publishable --missing-alias warn note.md

Dependencies:
    - frontmatter-parser
    - realpath
    - Bash version 4.3 or higher

Error codes:
    1: Invalid command line arguments
    2: Dependency command not found
    3: Invalid file path
    4: Missing or invalid aliases in front-matter
    99: Unexpected error
USAGE
}

# DEFAULTS INITIALIZATION
_arg_ignore_publish_state="off"
_arg_alias_mode="ignore"
_arg_file=""
_abs_file=""

parse_commandline() {
    local _key
    local -a _positionals=()
    while [[ $# -gt 0 ]]; do
        _key="$1"
        case "$_key" in
        --ignore-publish-state | --no-ignore-publish-state)
            _arg_ignore_publish_state="on"
            shift
            ;;
        --alias-mode)
            shift
            if [[ $# -lt 1 ]]; then
                _PRINT_HELP="on" die "--alias-mode requires a value." 1
            fi
            _arg_alias_mode="$1"
            shift
            ;;
        --alias-mode=*)
            _arg_alias_mode="${_key##--alias-mode=}"
            shift
            ;;
        -h | --help)
            print_help
            exit 0
            ;;
        -v | --verbose)
            shift
            if [[ $# -lt 1 ]]; then
                _PRINT_HELP="on" die "--verbose requires a value." 1
            fi
            _arg_verbose="$1"
            shift
            ;;
        -v=* | --verbose=*)
            _arg_verbose="${_key##*=}"
            shift
            ;;
        --quiet)
            _arg_verbose=0
            shift
            ;;
        --) # end of options
            shift
            while [[ $# -gt 0 ]]; do
                _positionals+=("$1")
                shift
            done
            ;;
        -*) # Unknown option
            _PRINT_HELP="on" die "Unknown option '$1'." 1
            ;;
        *)
            _positionals+=("$1")
            shift
            ;;
        esac
    done

    local -r _positionals_count=${#_positionals[@]}
    if [[ "${_positionals_count}" -lt 1 ]]; then
        _PRINT_HELP="on" die "No positional arguments provided." 1
    fi
    if [[ "${_positionals_count}" -gt 1 ]]; then
        _PRINT_HELP="on" die "Too many positional arguments provided (expected 1, got $_positionals_count)." 1
    fi

    _arg_file="${_positionals[0]}"
}

check_dependencies() {
    if ! command -v frontmatter-parser &>/dev/null; then
        die "Error: Could not find frontmatter-parser in PATH." 2
    fi
    if ! command -v realpath &>/dev/null; then
        die "Error: Could not find realpath in PATH." 2
    fi
    if (( BASH_VERSINFO[0] < 4 || ( BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 3 ) )); then
        die "Bash version 4.3 or higher is required. Current version is ${BASH_VERSION}." 2
    fi
}

validate_arguments() {
    if ! _abs_file=$(realpath "$_arg_file" 2>/dev/null); then
        die "Error: Could not resolve path for file '$_arg_file'." 3
    fi

    case "$_arg_alias_mode" in
        ignore | warn | error) ;;
        *) die "Invalid value for --alias-mode: '$_arg_alias_mode'. Allowed values are 'ignore', 'warn' or 'error'." 1 ;;
    esac

    case "$_arg_verbose" in
        0 | quiet) _arg_verbose=0 ;;
        1 | normal) _arg_verbose=1 ;;
        2 | verbose) _arg_verbose=2 ;;
        3 | debug) _arg_verbose=3 ;;
        *)
            _PRINT_HELP="on" die "Invalid value for --verbose: '$_arg_verbose'. Must be one of: 0 or 'quiet', 1 or 'normal', 2 or 'verbose', 3 or 'debug'." 1
            ;;
    esac

    # Internal errors
    case "$_arg_ignore_publish_state" in
        on | off) ;;
        *) die "Internal error: Invalid value for --ignore-publish-state: '$_arg_ignore_publish_state'. Allowed values are 'on' or 'off'." 1 ;;
    esac
}

is_publishable() {
    local -r _file="${1?Missing file argument}"
    local -r _ignore_publish_state="${2?Missing ignore publish state argument}"
    local _value
    if ! is_on "$_ignore_publish_state" && _value=$(frontmatter-parser --quiet --parameter "publish" --value-only -- "$_file"); then
        debug "File '$_file' has 'publish' set to '$_value'."
        # Only publish if true (so false, null, empty or any other value means not publishable)
        if [[ "$_value" == "true" ]]; then
            return 0
        else
            return 1
        fi
    else
        debug "Skipping publish state check for file '$_file' because --ignore-publish-state is set to 'on'."
        return 0
    fi
}

check_valid_aliases() {
    local -r _file="${1?Missing file argument}"
    local -r _alias_mode="${2?Missing alias mode argument}"

    if [[ "$_alias_mode" == "ignore" ]]; then
        debug "Not checking aliases for file '$_file' because --alias-mode is set to 'ignore'."
        return 0
    fi

    local _slug _url
    _slug=$(frontmatter-parser --quiet --parameter "slug" --value-only -- "$_file" || echo "")
    _url=$(frontmatter-parser --quiet --parameter "url" --value-only -- "$_file" || echo "")

    # Skip if no slug or url
    if [[ -z "$_slug" && -z "$_url" ]]; then
        debug "Not checking aliases for file '$_file' because it has no 'slug' or 'url' set."
        return 0
    fi

    local -a _aliases=()
    readarray -d '' -t _aliases < <(frontmatter-parser --quiet --parameter "aliases" --value-only --print0 -- "$_file")
    if [[ "${#_aliases[@]}" -eq 0 ]]; then
        case "$_alias_mode" in
        warn)
            warn "File '$_file' has 'slug' or 'url' set but no 'aliases' option."
            return 0
            ;;
        skip-file)
            log "Skipping file '$_file' because it has 'slug' or 'url' set but no 'aliases' option."
            return 1
            ;;
        error)
            die "Error: File '$_file' has 'slug' or 'url' set but no 'aliases' option." 4
            ;;
        esac
    fi

    # Remove leading slash and extension from filename
    local _clean_file_name
    _clean_file_name=${_file#/}
    _clean_file_name="${_clean_file_name%.*}"

    local _found_alias="false"
    local _alias
    for _alias in "${_aliases[@]}"; do
        # Check if alias ends with the cleaned filename
        if [[ "$_alias" == "*${_clean_file_name}" ]]; then
            _found_alias="true"
            break
        fi
    done

    if [[ "$_found_alias" == "false" ]]; then
        case "$_alias_mode" in
        warn)
            warn "File '$_file' has 'slug' or 'url' set but its filename '$_clean_file_name' is not in 'aliases'." >&2
            ;;
        skip-file)
            log "Skipping file '$_file' because it has 'slug' or 'url' set but its filename '$_clean_file_name' is not in 'aliases'." >&2
            return 1
            ;;
        error)
            die "Error: File '$_file' has 'slug' or 'url' set but its filename '$_clean_file_name' is not in 'aliases'." 4
            ;;
        esac
    fi
}

main() {
    # Validation and parsing
    check_dependencies
    parse_commandline "$@"
    validate_arguments

    if is_publishable "$_abs_file" "$_arg_ignore_publish_state" && check_valid_aliases "$_abs_file" "$_arg_alias_mode"; then
        debug "File '$_abs_file' is publishable."
        return 0
    else
        log "File '$_abs_file' is not publishable."
        return 1
    fi
}
main "$@"
