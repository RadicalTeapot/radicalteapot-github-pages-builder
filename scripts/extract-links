#!/usr/bin/env bash
set -eEuo pipefail

die() {
    local _ret="${2:-1}"
    [[ "${_PRINT_HELP:-no}" == "yes" ]] && print_help >&2
    printf '%s\n' "$1" >&2
    exit "$_ret"
}

trap 'die "Error (exit $?): ${BASH_SOURCE[1]}:${BASH_LINENO[0]} in ${FUNCNAME[1]:-main}" $?' ERR

print_help() {
    cat <<'USAGE'
Extract links from given markdown file and filter them based on criteria
Usage: extract-links [--internal] [--web] [--images] [--web-images] [-0|--print0] [-h|--help] <file>

Arguments:
    <file>: Markdown file to extract links from
    --internal: Extract only internal links (links starting with '/')
    --web: Extract only web links (links starting with 'http://' or 'https://')
    --images: Extract only image links (links starting with '!' followed by '[')
    --web-images: Extract only web image links (image links starting with '![' followed by 'http://' or 'https://')
    -0, --print0: Separate output links with null character (for use when piping to other commands)
    -h, --help: Prints help

Examples:
    extract-links ./content/posts/my-post.md
    extract-links --internal ./content/posts/my-post.md
    extract-links --web ./content/posts/my-post.md
    extract-links --internal --images ./content/posts/my-post.md

Remarks:
    If no filtering options are provided, all links will be extracted.

Error codes:
    1: Invalid command line arguments
    2: Missing or invalid file argument
    3: No links found matching the specified criteria
USAGE
}

_positionals=()
_arg_internal=
_arg_web=
_arg_images=
_arg_web_images=
_arg_file=""
_arg_print0="off"

# TODO: Check those
_INTERNAL_LINK_REGEX='\[[^][]*\]\((\/[^()]+)\)(.*$)'
_WEB_LINK_REGEX='\[[^][]*\]\((https?:\/\/[^()]+)\)(.*$)'
_INTERNAL_IMAGES_LINK_REGEX='!\[[^][]*\]\(([^()]+)\)(.*$)'
_WEB_IMAGES_LINK_REGEX='!\[[^][]*\]\((https?:\/\/[^()]+)\)(.*$)'

parse_commandline() {
    _positionals_count=0
    local _key
    while [[ $# -gt 0 ]]; do
        _key="$1"
        case "$_key" in
        --internal)
            _arg_internal="on"
            ;;
        --web)
            _arg_web="on"
            ;;
        --images)
            _arg_images="on"
            ;;
        --web-images)
            _arg_web_images="on"
            ;;
        -0 | --print0)
            _arg_print0="on"
            ;;
        -h | --help)
            print_help
            exit 0
            ;;
        *)
            _last_positional="$1"
            _positionals+=("$_last_positional")
            _positionals_count=$((_positionals_count + 1))
            ;;
        esac
        shift
    done
}

handle_passed_args_count() {
    local _required_args_string="'file'"
    [[ "${_positionals_count}" -ge 1 ]] || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
    [[ "${_positionals_count}" -le 1 ]] || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}

assign_positional_args() {
    # Note: this is where _arg_file gets filled (given to _positional_names and filled by eval in the loop)
    local _positional_name _shift_for=$1
    _positional_names="_arg_file " # space at the end is intentional

    shift "$_shift_for"
    for _positional_name in ${_positional_names}; do
        [[ $# -gt 0 ]] || break
        eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
        shift
    done
}

validate_arg_file() {
    [[ -n "$_arg_file" ]] || die "Error: Missing required argument: file" 2
    [[ -f "$_arg_file" ]] || die "Error: File '$_arg_file' does not exist or is not a regular file." 2
    [[ -r "$_arg_file" ]] || die "Error: File '$_arg_file' is not readable." 2
}

get_regexes() {
    local _link_regexes=()

    # Determine which link types to extract
    if [[ "$_arg_internal" == "on" ]]; then
        _link_regexes+=("$_INTERNAL_LINK_REGEX")
    fi
    if [[ "$_arg_web" == "on" ]]; then
        _link_regexes+=("$_WEB_LINK_REGEX")
    fi
    if [[ "$_arg_images" == "on" ]]; then
        _link_regexes+=("$_INTERNAL_IMAGES_LINK_REGEX")
    fi
    if [[ "$_arg_web_images" == "on" ]]; then
        _link_regexes+=("$_WEB_IMAGES_LINK_REGEX")
    fi

    # If no filters are set, extract all link types
    if [[ ${#_link_regexes[@]} -eq 0 ]]; then
        _link_regexes=(
            "$_INTERNAL_LINK_REGEX"
            "$_WEB_LINK_REGEX"
            "$_INTERNAL_IMAGES_LINK_REGEX"
            "$_WEB_IMAGES_LINK_REGEX"
        )
    fi

    printf '%s\n' "${_link_regexes[@]}"
}

main() {
    local -a _link_regexes
    while IFS= read -r regex; do
        _link_regexes+=("$regex")
    done< <(get_regexes)

    # Extract and print links based on the selected regexes
    local _lines=() _matching_lines _line
    for regex in "${_link_regexes[@]}"; do
        if _matching_lines=$(grep -oE "$regex" "$_arg_file"); then
            _line=""
            while IFS= read -r _line; do
                while [[ "$_line" =~ $regex ]]; do
                    _lines+=("${BASH_REMATCH[1]}")
                    _line="${BASH_REMATCH[2]:-}"
                done
            done < <(printf '%s\n' "$_matching_lines")
        fi
    done
    if [[ "${#_lines[@]}" -eq 0 ]]; then
        die "No links found matching the specified criteria." 3
    fi

    if [[ "$_arg_print0" == "on" ]]; then
        printf '%s\0' "${_lines[@]}" | LC_ALL=C sort -uz
    else
        printf '%s\n' "${_lines[@]}" | LC_ALL=C sort -u
    fi
}

# Validation and parsing
parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"
validate_arg_file

# Run the script
main
