#!/usr/bin/env bash
set -eEuo pipefail

# Helpers
log()   { printf '%s\n' "$*" >&2; }
warn()  { printf '[WARN]  %s\n' "$*" >&2; }
error() { printf '[ERROR] %s\n' "$*" >&2; }
is_on() { [[ "$1" == "on" ]]; }

die() {
    local _ret="${2:-1}"
    if [[ "${_PRINT_HELP:-no}" == "yes" ]]; then print_help >&2; fi
    error "$1"
    exit "$_ret"
}

trap 'die "Error (exit $?): ${BASH_SOURCE[1]}:${BASH_LINENO[0]} in ${FUNCNAME[1]:-main}" $?' ERR

print_help() {
    cat <<'USAGE'
Extract links from given markdown file and filter them based on criteria
Usage: extract-links [--internal] [--web] [--images] [--web-images] [-0|--print0] [-h|--help] [--] <file>

Arguments:
    <file>          Markdown file to extract links from
    -0, --print0    Separate output links with null character (for use when piping to other commands)
    -h, --help      Display this help message and exit
    --internal      Extract only internal links (links starting with '/')
    --web           Extract only web links (links starting with 'http://' or 'https://')
    --images        Extract only image links (links starting with '!' followed by '[')
    --web-images    Extract only web image links (image links starting with '![' followed by 'http://' or 'https://')
    --              End of options (useful if file paths start with a dash)

Examples:
    extract-links ./content/posts/my-post.md
    extract-links --internal ./content/posts/my-post.md
    extract-links --web --print0 ./content/posts/my-post.md
    extract-links --internal --images -- ./content/posts/my-post.md

Dependencies:
    - Bash 4.3 or higher

Remarks:
    If no filtering options are provided, all links will be extracted.

Error codes:
    1: Invalid command line arguments
    2: Missing or invalid file argument
USAGE
}

_positionals=()
_arg_internal=
_arg_web=
_arg_images=
_arg_web_images=
_arg_file=""
_arg_print0="off"

_INTERNAL_LINK_REGEX='\[[^][]*\]\([^()]+\)'
_WEB_LINK_REGEX='\[[^][]*\]\(https?:\/\/[^()]+\)'
_INTERNAL_IMAGES_LINK_REGEX='!\[[^][]*\]\([^()]+\)'
_WEB_IMAGES_LINK_REGEX='!\[[^][]*\]\(https?:\/\/[^()]+\)'
_CAPTURE_GROUP_REGEX='\((.*)\)$'

check_dependencies() {
    if ! (( BASH_VERSINFO[0] > 4 || (BASH_VERSINFO[0] >= 4 && BASH_VERSINFO[1] >= 3) )); then
        die "Bash version 4.3 or higher is required. Current version is ${BASH_VERSION}." 3
    fi
}

parse_commandline() {
    local _key
    while [[ $# -gt 0 ]]; do
        _key="$1"
        case "$_key" in
        --internal)
            _arg_internal="on"
            shift
            ;;
        --web)
            _arg_web="on"
            shift
            ;;
        --images)
            _arg_images="on"
            shift
            ;;
        --web-images)
            _arg_web_images="on"
            shift
            ;;
        -0 | --print0)
            _arg_print0="on"
            shift
            ;;
        -h | --help)
            print_help
            exit 0
            ;;
        --)
            shift
            while [[ $# -gt 0 ]]; do
                _positionals+=("$1")
                shift
            done
            ;;
        *)
            _positionals+=("$1")
            shift
            ;;
        esac
    done

    local _positionals_count=${#_positionals[@]}
    if [[ "${_positionals_count}" -lt 1 ]]; then
        _PRINT_HELP=yes die "One positional argument (file path) is required." 1
    fi
    if [[ "${_positionals_count}" -gt 1 ]]; then
        _PRINT_HELP=yes die "Too many positional arguments provided (expected 1, got $_positionals_count)." 1
    fi

    _arg_file="${_positionals[0]}"
}

validate_arg_file() {
    if [[ -z "$_arg_file" ]]; then die "Missing required argument: file" 2; fi
    if [[ ! -f "$_arg_file" ]]; then die "File '$_arg_file' does not exist or is not a regular file." 2; fi
    if [[ ! -r "$_arg_file" ]]; then die "File '$_arg_file' is not readable." 2; fi
}

get_internal_links() {
    local _file="${1:?Missing file argument}"
    local -n _internal_link_ref="${2:?Missing result array name argument}"
    local _matching_lines _line
    _matching_lines=$(grep -oE "$_INTERNAL_LINK_REGEX" "$_file" | grep -Ev "$_WEB_LINK_REGEX" || true)
    _line=""
    while IFS= read -r _line; do
        if [[ "$_line" =~ $_CAPTURE_GROUP_REGEX ]]; then
            _internal_link_ref+=("${BASH_REMATCH[1]}")
        fi
    done < <(printf '%s\n' "$_matching_lines")
}

get_web_links() {
    local _file="${1:?Missing file argument}"
    local -n _web_link_ref="${2:?Missing result array name argument}"
    local _matching_lines _line
    _matching_lines=$(grep -oE "$_WEB_LINK_REGEX" "$_file" || true)
    _line=""
    while IFS= read -r _line; do
        if [[ "$_line" =~ $_CAPTURE_GROUP_REGEX ]]; then
            _web_link_ref+=("${BASH_REMATCH[1]}")
        fi
    done < <(printf '%s\n' "$_matching_lines")
}

get_internal_image_links() {
    local _file="${1:?Missing file argument}"
    local -n _internal_image_ref="${2:?Missing result array name argument}"
    local _matching_lines _line
    _matching_lines=$(grep -oE "$_INTERNAL_IMAGES_LINK_REGEX" "$_file" | grep -Ev "$_WEB_IMAGES_LINK_REGEX" || true)
    _line=""
    while IFS= read -r _line; do
        if [[ "$_line" =~ $_CAPTURE_GROUP_REGEX ]]; then
            _internal_image_ref+=("${BASH_REMATCH[1]}")
        fi
    done < <(printf '%s\n' "$_matching_lines")
}

get_web_image_links() {
    local _file="${1:?Missing file argument}"
    local -n _web_image_ref="${2:?Missing result array name argument}"
    local _matching_lines _line
    _matching_lines=$(grep -oE "$_WEB_IMAGES_LINK_REGEX" "$_file" || true)
    _line=""
    while IFS= read -r _line; do
        if [[ "$_line" =~ $_CAPTURE_GROUP_REGEX ]]; then
            _web_image_ref+=("${BASH_REMATCH[1]}")
        fi
    done < <(printf '%s\n' "$_matching_lines")
}

get_results() {
    # Note: name of nameref has to be unique within the function scope
    local -n _results_ref="${1:?Missing result array name argument}"

    local _get_all="off"
    # If no filters are set, extract all link types
    if ! is_on "$_arg_internal" && ! is_on "$_arg_web" && ! is_on "$_arg_images" && ! is_on "$_arg_web_images"; then
        _get_all="on"
    fi

    if is_on "$_arg_internal" || is_on "$_get_all"; then
        get_internal_links "$_arg_file" _results_ref
    fi
    if is_on "$_arg_web" || is_on "$_get_all"; then
        get_web_links "$_arg_file" _results_ref
    fi
    if is_on "$_arg_images" || is_on "$_get_all"; then
        get_internal_image_links "$_arg_file" _results_ref
    fi
    if is_on "$_arg_web_images" || is_on "$_get_all"; then
        get_web_image_links "$_arg_file" _results_ref
    fi
}

main() {
    check_dependencies
    parse_commandline "$@"
    validate_arg_file

    local -a _results=()
    get_results _results

    if [[ "${#_results[@]}" -eq 0 ]]; then
        printf ''  # Print nothing
    else
        if [[ "$_arg_print0" == "on" ]]; then
            printf '%s\0' "${_results[@]}" | LC_ALL=C sort -uz
        else
            printf '%s\n' "${_results[@]}" | LC_ALL=C sort -u
        fi
    fi
}
main "$@"
