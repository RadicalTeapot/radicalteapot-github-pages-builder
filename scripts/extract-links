#!/usr/bin/env bash
set -eEuo pipefail

# Helpers
log()   { printf '%s\n' "$*" >&2; }
warn()  { printf '[WARN]  %s\n' "$*" >&2; }
error() { printf '[ERROR] %s\n' "$*" >&2; }
is_on() { [[ "$1" == "on" ]]; }

die() {
    local _ret="${2:-1}"
    if [[ "${_PRINT_HELP:-no}" == "yes" ]]; then print_help >&2; fi
    error "$1"
    exit "$_ret"
}

trap 'die "Error (exit $?): ${BASH_SOURCE[1]}:${BASH_LINENO[0]} in ${FUNCNAME[1]:-main}" $?' ERR

print_help() {
    cat <<'USAGE'
Extract links from given markdown file and filter them based on criteria
Usage: extract-links [--internal] [--web] [--images] [--web-images] [-0|--print0] [-h|--help] [--] <file>

Arguments:
    <file>          Markdown file to extract links from
    -0, --print0    Separate output links with null character (for use when piping to other commands)
    -h, --help      Display this help message and exit
    --internal      Extract only internal links (links starting with '/')
    --web           Extract only web links (links starting with 'http://' or 'https://')
    --images        Extract only image links (links starting with '!' followed by '[')
    --web-images    Extract only web image links (image links starting with '![' followed by 'http://' or 'https://')
    --              End of options (useful if file paths start with a dash)

Examples:
    extract-links ./content/posts/my-post.md
    extract-links --internal ./content/posts/my-post.md
    extract-links --web --print0 ./content/posts/my-post.md
    extract-links --internal --images -- ./content/posts/my-post.md

Remarks:
    If no filtering options are provided, all links will be extracted.

Error codes:
    1: Invalid command line arguments
    2: Missing or invalid file argument
    3: No links found matching the specified criteria
USAGE
}

_positionals=()
_arg_internal=
_arg_web=
_arg_images=
_arg_web_images=
_arg_file=""
_arg_print0="off"

# TODO: Check those
_INTERNAL_LINK_REGEX='\[[^][]*\]\(([^()]+)\)(.*$)'
_WEB_LINK_REGEX='\[[^][]*\]\((https?:\/\/[^()]+)\)(.*$)'
_INTERNAL_IMAGES_LINK_REGEX='!\[[^][]*\]\(([^()]+)\)(.*$)'
_WEB_IMAGES_LINK_REGEX='!\[[^][]*\]\((https?:\/\/[^()]+)\)(.*$)'

parse_commandline() {
    local _key
    while [[ $# -gt 0 ]]; do
        _key="$1"
        case "$_key" in
        --internal)
            _arg_internal="on"
            shift
            ;;
        --web)
            _arg_web="on"
            shift
            ;;
        --images)
            _arg_images="on"
            shift
            ;;
        --web-images)
            _arg_web_images="on"
            shift
            ;;
        -0 | --print0)
            _arg_print0="on"
            shift
            ;;
        -h | --help)
            print_help
            exit 0
            ;;
        --)
            shift
            while [[ $# -gt 0 ]]; do
                _positionals+=("$1")
                shift
            done
            ;;
        *)
            _positionals+=("$1")
            shift
            ;;
        esac
    done

    local _positionals_count=${#_positionals[@]}
    if [[ "${_positionals_count}" -lt 1 ]]; then
        _PRINT_HELP=yes die "One positional argument (file path) is required." 1
    fi
    if [[ "${_positionals_count}" -gt 1 ]]; then
        _PRINT_HELP=yes die "Too many positional arguments provided (expected 1, got $_positionals_count)." 1
    fi

    _arg_file="${_positionals[0]}"
}

validate_arg_file() {
    if [[ -z "$_arg_file" ]]; then die "Missing required argument: file" 2; fi
    if [[ ! -f "$_arg_file" ]]; then die "File '$_arg_file' does not exist or is not a regular file." 2; fi
    if [[ ! -r "$_arg_file" ]]; then die "File '$_arg_file' is not readable." 2; fi
}

get_regexes() {
    local _link_regexes=()

    # Determine which link types to extract
    if [[ "$_arg_internal" == "on" ]]; then
        _link_regexes+=("$_INTERNAL_LINK_REGEX")
    fi
    if [[ "$_arg_web" == "on" ]]; then
        _link_regexes+=("$_WEB_LINK_REGEX")
    fi
    if [[ "$_arg_images" == "on" ]]; then
        _link_regexes+=("$_INTERNAL_IMAGES_LINK_REGEX")
    fi
    if [[ "$_arg_web_images" == "on" ]]; then
        _link_regexes+=("$_WEB_IMAGES_LINK_REGEX")
    fi

    # If no filters are set, extract all link types
    if [[ ${#_link_regexes[@]} -eq 0 ]]; then
        _link_regexes=(
            "$_INTERNAL_LINK_REGEX"
            "$_WEB_LINK_REGEX"
            "$_INTERNAL_IMAGES_LINK_REGEX"
            "$_WEB_IMAGES_LINK_REGEX"
        )
    fi

    printf '%s\n' "${_link_regexes[@]}"
}

main() {
    local -a _link_regexes
    while IFS= read -r regex; do
        _link_regexes+=("$regex")
    done< <(get_regexes)

    # Extract and print links based on the selected regexes
    local _lines=() _matching_lines _line
    for regex in "${_link_regexes[@]}"; do
        if _matching_lines=$(grep -oE "$regex" "$_arg_file"); then
            _line=""
            while IFS= read -r _line; do
                while [[ "$_line" =~ $regex ]]; do
                    _lines+=("${BASH_REMATCH[1]}")
                    _line="${BASH_REMATCH[2]:-}"
                done
            done < <(printf '%s\n' "$_matching_lines")
        fi
    done
    if [[ "${#_lines[@]}" -eq 0 ]]; then
        die "No links found matching the specified criteria." 3
    fi

    if [[ "$_arg_print0" == "on" ]]; then
        printf '%s\0' "${_lines[@]}" | LC_ALL=C sort -uz
    else
        printf '%s\n' "${_lines[@]}" | LC_ALL=C sort -u
    fi
}

# Validation and parsing
parse_commandline "$@"
validate_arg_file

# Run the script
main
