#!/usr/bin/env bash
set -eEuo pipefail

log()  { printf '%s\n' "$*" >&2; }
log_warn()  { printf '[WARN]  %s\n' "$*" >&2; }
log_error() { printf '[ERROR] %s\n' "$*" >&2; }

die() {
    local _ret="${2:-1}"
    [[ "${_PRINT_HELP:-no}" == "yes" ]] && print_help >&2
    log_error "$1"
    exit "$_ret"
}

trap 'die "Error (exit $?): ${BASH_SOURCE[1]:-${BASH_SOURCE[0]}}:${BASH_LINENO[0]} in ${FUNCNAME[1]:-main}" 99' ERR

print_help() {
    cat <<'USAGE'
Publish site to the specified output directory
Usage: publish-site [-c|--clean] [-h|--help] [--yes] <source-directory> <output-directory>

Arguments:
    <source-directory>: Directory containing the site source files
    <output-directory>: Directory where the site will be published
    -c, --clean: Clean the output directory before publishing, default is off
    --yes: Assume "yes" for clean confirmation prompts
    -h, --help: Show this help message and exit

Examples:
    publish-site ./site ./public
    publish-site --clean ./site ./public

Dependencies:
    - get-files-to-publish
    - extract-links
    - rsync
    - realpath
    - Bash version 4 or higher

Error codes:
    1: Invalid command line arguments
    2: Missing or invalid source or output directory argument
    3: Cleaning errors
    4: Failed to copy files
    5: Dependency issues
    99: Unexpected error
USAGE
}

_positionals=()
_arg_clean="off"
_arg_yes="off"
_arg_source_directory=""
_arg_output_directory=""
_src=""
_out=""

_default_publish_args=(--only-published --missing-alias "warn")

check_dependencies() {
    command -v get-files-to-publish &>/dev/null || \
        die "get-files-to-publish command not found. Please install it and ensure it's in your PATH." 5
    command -v extract-links &>/dev/null || \
        die "extract-links command not found. Please install it and ensure it's in your PATH." 5
    command -v rsync &>/dev/null || \
        die "rsync command not found. Please install it and ensure it's in your PATH." 5
    command -v realpath &>/dev/null || \
        die "realpath command not found. Please install it and ensure it's in your PATH." 5
    if (( BASH_VERSINFO[0] < 4 )); then
        die "Bash version 4 or higher is required. Current version is ${BASH_VERSION}." 5
    fi
}

parse_commandline() {
    _positionals_count=0
    local _key
    while [[ $# -gt 0 ]]; do
        _key="$1"
        case "$_key" in
        -c | --clean)
            _arg_clean="on"
            shift
            ;;
        -h | --help)
            print_help
            exit 0
            ;;
        --yes)
            _arg_yes="on"
            shift
            ;;
        --) # end argument parsing
            shift
            while [[ $# -gt 0 ]]; do
                _positionals+=("$1")
                shift
            done
            ;;
        -*) # unknown option
            _PRINT_HELP=yes die "Unknown option: '$_key'" 1
            ;;
        *) # positional argument
            _positionals+=("$1")
            shift
            ;;
        esac
    done

    _positionals_count="${#_positionals[@]}"
    if [[ "${_positionals_count}" -gt 2 ]]; then
        die "Too many positional arguments: expected at most 2, got ${_positionals_count}" 1
    fi
    if [[ "${_positionals_count}" -ge 1 ]]; then
        _arg_source_directory="${_positionals[0]}"
    fi
    if [[ "${_positionals_count}" -ge 2 ]]; then
        _arg_output_directory="${_positionals[1]}"
    fi
}

validate_arguments() {
    if [[ "$_arg_clean" != "on" && "$_arg_clean" != "off" ]]; then
        die "Invalid value for --clean: '$_arg_clean'. Expected 'on' or 'off'." 1
    fi

    if [[ -z "$_arg_source_directory" || -z "$_arg_output_directory" ]]; then
        die "Both source and output directories must be specified." 2
    fi

    if [[ ! -d "$_arg_source_directory" ]]; then
        die "Source directory '$_arg_source_directory' does not exist or is not a directory." 2
    fi
}

resolve_directories() {
    _src="$(realpath "$_arg_source_directory")" || die "Cannot resolve source." 2
    _out="$(realpath "$_arg_output_directory")" || die "Cannot resolve output." 2
}

# -- publish site --
clean_output_directory() {
    if [[ "$_arg_clean" != "on" ]]; then
        return 0
    fi

    local _home
    _home="$(realpath "$HOME")"
    # Security check to prevent accidental deletion of important directories
    case "$_out" in
        /|""|"."|".."|"/root"|"/home"|"/usr"|"/etc"|"/var"|"$_home"|"$_home/."|"$_home/..")
        die "Refusing to clean output directory '$_out' for safety reasons." 3
        ;;
    esac
    if mountpoint -q "$_out"; then
        die "Refusing to clean output directory '$_out' because it is a mount point." 3
    fi

    # Check if the output directory is the same as the source directory
    if [[ "$_out" == "$_src" ]]; then
        die "Output directory '$_out' cannot be the same as the source directory '$_src'." 3
    fi

    # Check if the output directory is a parent of the source directory
    if [[ "$_src" == "$_out"/* ]]; then
        die "Output directory '$_out' cannot be a parent of the source directory '$_src'." 3
    fi
    if [[ "$_out" == "$_src"/* ]]; then
        die "Output directory '$_out' cannot be a subdirectory of the source directory '$_src'." 3
    fi

    if [[ -d "$_out" ]]; then
        if [[ ! -w "$_out" ]]; then
            die "Output directory '$_out' is not writable." 3
        fi

        # Ask for confirmation
        if [[ "$_arg_yes" != "on" ]]; then
            if [[ ! -t 0 ]]; then die "Non-interactive shell: pass --yes to clean." 3; fi
            read -r -p "Are you sure you want to clean '$_out' before publishing? [y/N] " _reply
            if [[ ! "$_reply" =~ ^[Yy]$ ]]; then
                die "Aborted by user." 3
            fi
        fi

        log "Cleaning output directory '$_out'..."
        # Clean the output content and preserve the directory itself for safety
        # shellcheck disable=SC2115 # (safe because of previous checks)
        rm -rf -- "$_out"/* "$_out"/.[!.]* "$_out"/..?* 2>/dev/null || true
    else
        mkdir -p -- "$_out" || die "Failed to create output directory '$_out'." 3
    fi
}

# Convert absolute paths to relative paths based on source directory
# Arguments: list of file paths (absolute or source-relative)
# Outputs: NUL-separated list of relative paths
# Note: this assumes file paths are either source-relative or absolute, empty paths are ignored, duplicates are removed
# Exits with error if a file is outside the source directory
get_clean_relative_path_list() {
    local -a _relative_files
    local -A _seen=()
    local _file _relative
    for _file in "$@"; do
        [[ -z "$_file" ]] && continue # skip empty

        if [[ "$_file" != /* ]]; then
            _file="$(realpath "$_src/${_file#./}")" || continue
        else
            _file="$(realpath "$_file")" || continue
        fi

        if [[ "$_file" != "$_src/"* ]]; then
            if [[ ${_FAIL_ON_INVALID:-no} == "yes" ]]; then
                die "Found invalid file path '$_file' (outside source directory)." 4
            fi
            log_warn "Skipping file '$_file' outside source directory."
            continue # skip files outside source directory
        fi
        _relative="${_file#"$_src"/}" # make relative to source

        [[ -n "${_seen["$_relative"]+_}" ]] && continue # skip duplicates
        _seen["$_relative"]=1

        _relative_files+=("$_relative")
    done
    printf '%s\0' "${_relative_files[@]}"
}

# Get list of files to copy, including images linked in the files
# Outputs: NUL-separated list of file paths relative to source directory
# Exits with error if a file is outside the source directory
get_files_and_images_to_copy() {
    local -a _files_to_copy=()
    local _files
    if ! _files=$(get-files-to-publish "${_default_publish_args[@]}" "$_src"); then
        die "Failed to get files to publish." 4
    fi
    readarray -d '' -t _files_to_copy <<<"$_files"
    readarray -d '' -t _files_to_copy < <(_FAIL_ON_INVALID=yes get_clean_relative_path_list "${_files_to_copy[@]}")

    local -a _images_to_copy=()
    for _file in "${_files_to_copy[@]}"; do
        local -a _imgs=()
        readarray -d '' -t _imgs < <(extract-links --images --print0 "$_file" || true)
        _images_to_copy+=("${_imgs[@]}")
    done
    readarray -d '' -t _images_to_copy < <(_FAIL_ON_INVALID=yes get_clean_relative_path_list "${_images_to_copy[@]}")

    # Merge image files into main file list
    local _img
    for _img in "${_images_to_copy[@]}"; do
        _files_to_copy+=("$_img")
    done

    printf '%s\0' "${_files_to_copy[@]}"
}

# Check for dead internal links in the files to be published
# Arguments: list of file paths (relative to source directory)
# Outputs: warnings for dead links
# Exits with error if a link points outside the source directory
check_dead_links() {
    local -a _files_to_copy=( "$@" )

    local -A _file_set=()
    for _file in "${_files_to_copy[@]}"; do
        _file_set["$_file"]=1
    done

    local _file
    for _file in "${_files_to_copy[@]}"; do
        local -a _internal_links=()
        readarray -d '' -t _internal_links < <(extract-links --internal --images --print0 "$_file" || true)
        readarray -d '' -t _internal_links < <(_FAIL_ON_INVALID=no get_clean_relative_path_list "${_internal_links[@]}" 2>/dev/null || true)

        local _link _target_src
        for _link in "${_internal_links[@]}"; do
            if [[ -z "${_file_set["$_link"]+_}" ]]; then
                log_warn "Internal link '$_link' in file '$_file' does not point to a published file."
            fi
        done
    done
}

copy_files() {
    local -a _relative_files=( "$@" )

    # Build NUL-separated list file for rsync
    local _list_file
    _list_file=$(mktemp) || die "Failed to create temporary file." 4
    trap 'rm -f -- "$_list_file"' EXIT
    {
        printf '%s\0' "${_relative_files[@]}"
    } > "$_list_file"

    log "Copying ${#_relative_files[@]} files to '$_out' with rsync..."
    rsync -a --files-from="$_list_file" --from0 "$_src"/ "$_out"/ \
        || die "Failed to copy files to '$_out'." 4
}

main() {
    check_dependencies
    parse_commandline "$@"
    validate_arguments
    resolve_directories
    clean_output_directory

    local -a _files_to_copy=()
    readarray -d '' -t _files_to_copy < <(get_files_and_images_to_copy)

    if [[ "${#_files_to_copy[@]}" -eq 0 ]]; then
        log "No files to publish."
        exit 0
    fi

    check_dead_links "${_files_to_copy[@]}"
    copy_files "${_files_to_copy[@]}"
}
main "$@"
