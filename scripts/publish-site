#!/usr/bin/env bash
set -eEuo pipefail

# Error codes
EX_USAGE=101          # CLI misuse / invalid flags
EX_NO_INPUT=102       # Missing or invalid source directory
EX_NO_OUTPUT=103      # Missing or invalid output directory
EX_CLEANING_ERROR=104 # Cleaning errors
EX_COPY_ERROR=105     # Failed to copy files
EX_DEP_ISSUE=106      # Dependency issues
EX_INV_FILE=107       # Invalid file path
EX_INTERNAL=198       # Internal error
EX_UNKNOWN=199        # Unexpected error

# Usage string
USAGE="Usage: publish-site [-c|--clean] [-h|--help] [--yes] <source-directory> <output-directory>"

_verbose_level=1

debug() { if (( _verbose_level >= 3 )); then printf '[DEBUG] %s\n' "$*" >&2; fi; }
log()   { if (( _verbose_level >= 2 )); then printf '%s\n' "$*" >&2; fi; }
warn()  { if (( _verbose_level >= 1 )); then printf '[WARN] %s\n' "$*" >&2; fi; }
error() { printf '[ERROR] %s\n' "$*" >&2; }
is_on() { [[ "$1" == "on" ]]; }

die() {
    local -r _message="${1:-"Unknown error"}"
    local -r _ret="${2:-${EX_UNKNOWN}}"
    if is_on "${_PRINT_USAGE:-no}" && (( _verbose_level > 0 )); then "$USAGE" >&2; fi
    local _err_tag=""
    case "$_ret" in
        "$EX_USAGE") _err_tag="[USAGE]" ;;
        "$EX_NO_INPUT") _err_tag="[NO_INPUT]" ;;
        "$EX_NO_OUTPUT") _err_tag="[NO_OUTPUT]" ;;
        "$EX_CLEANING_ERROR") _err_tag="[CLEANING_ERROR]" ;;
        "$EX_COPY_ERROR") _err_tag="[COPY_ERROR]" ;;
        "$EX_DEP_ISSUE") _err_tag="[DEP_ISSUE]" ;;
        "$EX_INV_FILE") _err_tag="[INV_FILE]" ;;
        "$EX_INTERNAL") _err_tag="[INTERNAL]" ;;
        "$EX_UNKNOWN") _err_tag="[UNKNOWN]" ;;
        *) _err_tag="[CODE_${_ret}]" ;;
    esac
    error "$_err_tag $_message"
    exit "$_ret"
}

trap 'die "(exit $?): ${BASH_SOURCE[1]:-${BASH_SOURCE[0]}}:${LINENO} in ${FUNCNAME[1]:-main}" ${EX_UNKNOWN}' ERR

print_help() {
    cat <<USAGE
Publish site to the specified output directory
${USAGE}

Arguments:
    <source-directory>: Directory containing the site source files
    <output-directory>: Directory where the site will be published
    -c, --clean: Clean the output directory before publishing, default is off
    --yes: Assume "yes" for clean confirmation prompts
    -h, --help: Show this help message and exit

Examples:
    publish-site ./site ./public
    publish-site --clean ./site ./public

Dependencies:
    - get-files-to-publish
    - extract-links
    - rsync
    - realpath
    - Bash version 4.3 or higher

Error codes:
    ${EX_USAGE}          Command line usage error (invalid flags, missing arguments)
    ${EX_NO_INPUT}       Input file not found
    ${EX_NO_OUTPUT}      Output directory issues
    ${EX_CLEANING_ERROR} Cleaning errors
    ${EX_COPY_ERROR}     Failed to copy files
    ${EX_DEP_ISSUE}      Dependency missing or unusable
    ${EX_INV_FILE}       Invalid file path
    ${EX_INTERNAL}       Internal error
    ${EX_UNKNOWN}        Unexpected error
USAGE
}

# DEFAULTS INITIALIZATION
_arg_verbose=1
_arg_clean="off"
_arg_yes="off"
_arg_source_directory=""
_arg_output_directory=""
_src=""
_out=""

parse_commandline() {
    local _key
    local -a _positionals=()
    while [[ $# -gt 0 ]]; do
        _key="$1"
        case "$_key" in
        -c | --clean)
            _arg_clean="on"
            shift
            ;;
        -h | --help)
            print_help
            exit 0
            ;;
        --yes)
            _arg_yes="on"
            shift
            ;;
        --) 
            # End of options
            shift
            while [[ $# -gt 0 ]]; do
                _positionals+=("$1")
                shift
            done
            ;;
        -*) 
            # Unknown option
            _PRINT_USAGE="on" die "Unknown option: '$_key'" $EX_USAGE
            ;;
        *) 
            # Positional argument
            _positionals+=("$1")
            shift
            ;;
        esac
    done

    local -r _positionals_count="${#_positionals[@]}"
    if [[ "${_positionals_count}" -lt 2 ]]; then
        die "Not enough positional arguments: expected 2, got ${_positionals_count}" $EX_USAGE
    fi
    if [[ "${_positionals_count}" -gt 2 ]]; then
        die "Too many positional arguments: expected at most 2, got ${_positionals_count}" $EX_USAGE
    fi

    _arg_source_directory="${_positionals[0]}"
    _arg_output_directory="${_positionals[1]}"
}

check_dependencies() {
    if ! command -v get-files-to-publish &>/dev/null; then
        die "get-files-to-publish command not found. Please install it and ensure it's in your PATH." $EX_DEP_ISSUE
    fi
    if ! command -v extract-links &>/dev/null; then
        die "extract-links command not found. Please install it and ensure it's in your PATH." $EX_DEP_ISSUE
    fi
    if ! command -v rsync &>/dev/null; then
        die "rsync command not found. Please install it and ensure it's in your PATH." $EX_DEP_ISSUE
    fi
    if ! command -v realpath &>/dev/null; then
        die "realpath command not found. Please install it and ensure it's in your PATH." $EX_DEP_ISSUE
    fi

    if (( BASH_VERSINFO[0] < 4 || ( BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 3 ) )); then
        die "Bash version 4.3 or higher is required. Current version is ${BASH_VERSION}." $EX_DEP_ISSUE
    fi
}

validate_arguments() {
    if [[ -z "$_arg_source_directory" ]]; then
        die "Both source and output directories must be specified." $EX_NO_INPUT
    fi

    if [[ ! -d "$_arg_source_directory" ]]; then
        die "Source directory '$_arg_source_directory' does not exist or is not a directory." $EX_NO_INPUT
    fi

    if [[ -z "$_arg_output_directory" ]]; then
        die "Both source and output directories must be specified." $EX_NO_OUTPUT
    fi

    if [[ ! -d "$_arg_output_directory" ]]; then
        if ! mkdir -p -- "$_arg_output_directory"; then
            die "Output directory '$_arg_output_directory' does not exist and cannot be created." $EX_NO_OUTPUT
        fi
    fi

    # Internal checks
    case "$_arg_clean" in
        on | off) ;;
        *) die "Internal error: Invalid value for --clean: '$_arg_clean'. Allowed values are 'on' or 'off'." $EX_INTERNAL ;;
    esac

    case "$_arg_yes" in
        on | off) ;;
        *) die "Internal error: Invalid value for --yes: '$_arg_yes'. Allowed values are 'on' or 'off'." $EX_INTERNAL ;;
    esac
}

resolve_directories() {
    if ! _src="$(realpath "$_arg_source_directory")"; then 
        die "Cannot resolve source." $EX_NO_INPUT; 
    fi

    if ! _out="$(realpath "$_arg_output_directory")"; then 
        die "Cannot resolve output." $EX_NO_OUTPUT; 
    fi
}

clean_output_directory() {
    if ! is_on "$_arg_clean"; then
        return 0
    fi

    local _home
    _home="$(realpath "$HOME")"
    # Security check to prevent accidental deletion of important directories
    case "$_out" in
        /|""|"."|".."|"/root"|"/home"|"/usr"|"/etc"|"/var"|"$_home"|"$_home/."|"$_home/..")
        die "Refusing to clean output directory '$_out' for safety reasons." $EX_CLEANING_ERROR
        ;;
    esac
    if mountpoint -q "$_out"; then
        die "Refusing to clean output directory '$_out' because it is a mount point." $EX_CLEANING_ERROR
    fi

    # Check if the output directory is the same as the source directory
    if [[ "$_out" == "$_src" ]]; then
        die "Output directory '$_out' cannot be the same as the source directory '$_src'." $EX_CLEANING_ERROR
    fi

    # Check if the output directory is a parent of the source directory
    if [[ "$_src" == "$_out"/* ]]; then
        die "Output directory '$_out' cannot be a parent of the source directory '$_src'." $EX_CLEANING_ERROR
    fi
    if [[ "$_out" == "$_src"/* ]]; then
        die "Output directory '$_out' cannot be a subdirectory of the source directory '$_src'." $EX_CLEANING_ERROR
    fi

    if [[ -d "$_out" ]]; then
        if [[ ! -w "$_out" ]]; then
            die "Output directory '$_out' is not writable." $EX_CLEANING_ERROR
        fi

        # Ask for confirmation
        if [[ "$_arg_yes" != "on" ]]; then
            if [[ ! -t 0 ]]; then die "Non-interactive shell: pass --yes to clean." $EX_CLEANING_ERROR; fi
            read -r -p "Are you sure you want to clean '$_out' before publishing? [y/N] " _reply
            if [[ ! "$_reply" =~ ^[Yy]$ ]]; then
                die "Aborted by user." $EX_CLEANING_ERROR
            fi
        fi

        log "Cleaning output directory '$_out'..."
        # Clean the output content and preserve the directory itself for safety
        # shellcheck disable=SC2115 # (safe because of previous checks)
        rm -rf -- "$_out"/* "$_out"/.[!.]* "$_out"/..?* 2>/dev/null || true
    else
        mkdir -p -- "$_out" || die "Failed to create output directory '$_out'." $EX_CLEANING_ERROR
    fi
}

# Convert absolute paths to relative paths based on source directory
# Arguments:
#   - array to fill with relative file paths
#   - list of file paths (absolute or source-relative)
# Note: this assumes file paths are either source-relative or absolute, empty paths are ignored, duplicates are removed
# Exits with error if a file is outside the source directory
get_clean_relative_path_list() {
    local -n _relative_files_ref="${1:?Internal error: Missing argument to get_clean_relative_path_list}"
    shift
    local _fail_on_invalid="${1:-off}"
    shift

    local -A _seen=()
    local _file _relative
    for _file in "$@"; do
        if [[ -z "$_file" ]]; then
            continue # skip empty
        fi

        if [[ "$_file" != /* ]]; then
            _file="$(realpath "$_src/${_file#./}")" || continue
        else
            _file="$(realpath "$_file")" || continue
        fi

        if [[ "$_file" != "$_src/"* ]]; then
            if is_on "${_FAIL_ON_INVALID:-off}"; then
                die "Found invalid file path '$_file' (outside source directory)." $EX_INV_FILE
            fi
            warn "Skipping file '$_file' outside source directory."
            continue # skip files outside source directory
        fi
        _relative="${_file#"$_src"/}" # make relative to source

        if [[ -n "${_seen["$_relative"]+_}" ]]; then
            continue # skip duplicates
        fi

        _seen["$_relative"]=1
        _relative_files_ref+=("$_relative")
    done
}

# Get list of files to copy, including images linked in the files
# Arguments: array to fill with file paths (relative to source directory)
# Exits with error if a file is outside the source directory
get_files_and_images_to_copy() {
    local -n _files_to_copy_ref="${1?Internal error: Missing argument to get_files_and_images_to_copy}"

    local -a _files_to_publish=()
    if ! readarray -d '' -t _files_to_publish < <(get-files-to-publish --print0 --alias-mode "warn" "$_src"); then
        die "Failed to get files to publish." $EX_COPY_ERROR
    fi

    if [[ "${#_files_to_publish[@]}" -eq 0 ]]; then
        return 0
    fi

    get_clean_relative_path_list _files_to_copy_ref "on" "${_files_to_publish[@]}"

    local -a _images_to_publish=()
    for _file in "${_files_to_publish[@]}"; do
        local -a _imgs=()
        if ! readarray -d '' -t _imgs < <(extract-links --images --print0 "$_file"); then
            die "Failed to extract image links from file '$_file'." $EX_COPY_ERROR
        fi
        if [[ "${#_imgs[@]}" -gt 0 ]]; then
            _images_to_publish+=("${_imgs[@]}")
        fi
    done
    get_clean_relative_path_list _files_to_copy_ref "on" "${_images_to_publish[@]}"
}

# Check for dead internal links in the files to be published
# Arguments: list of file paths (relative to source directory)
# Outputs: warnings for dead links
# Exits with error if a link points outside the source directory
check_dead_links() {
    local -a _files_to_copy=( "$@" )

    local -A _file_set=()
    for _file in "${_files_to_copy[@]}"; do
        _file_set["$_file"]=1
    done

    local _file
    for _file in "${_files_to_copy[@]}"; do
        local -a _internal_links=()
        local _abs_file="$_src/$_file"
        readarray -d '' -t _internal_links < <(extract-links --internal --images --print0 "$_abs_file" || true)
        get_clean_relative_path_list _internal_links "no" "${_internal_links[@]}" || true

        local _link _target_src
        for _link in "${_internal_links[@]}"; do
            if [[ -z "${_file_set["$_link"]+_}" ]]; then
                warn "Internal link '$_link' in file '$_file' does not point to a published file."
            fi
        done
    done
}

copy_files() {
    local -a _relative_files=( "$@" )

    # Build NUL-separated list file for rsync
    local _list_file
    _list_file=$(mktemp) || die "Failed to create temporary file." $EX_COPY_ERROR
    trap 'rm -f -- '"$_list_file" EXIT

    {
        printf '%s\0' "${_relative_files[@]}"
    } > "$_list_file"

    log "Copying ${#_relative_files[@]} files to '$_out' with rsync..."
    if ! rsync -a --files-from="$_list_file" --from0 "$_src"/ "$_out"/; then
        die "Failed to copy files to '$_out'." $EX_COPY_ERROR
    fi
}

main() {
    check_dependencies
    parse_commandline "$@"
    validate_arguments
    resolve_directories
    clean_output_directory

    local -a _files_to_copy=()
    get_files_and_images_to_copy _files_to_copy

    if [[ "${#_files_to_copy[@]}" -eq 0 ]]; then
        log "No files to publish."
        exit 0
    fi

    check_dead_links "${_files_to_copy[@]}"
    copy_files "${_files_to_copy[@]}"
}
main "$@"
