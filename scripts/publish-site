#!/usr/bin/env bash
set -eEuo pipefail

log()  { printf '%s\n' "$*" >&2; }
log_warn()  { printf '[WARN]  %s\n' "$*" >&2; }
log_error() { printf '[ERROR] %s\n' "$*" >&2; }
is_on() { [[ "$1" == "on" ]]; }

die() {
    local _ret="${2:-1}"
    [[ "${_PRINT_HELP:-no}" == "yes" ]] && print_help >&2
    log_error "$1"
    exit "$_ret"
}

trap 'die "Error (exit $?): ${BASH_SOURCE[1]:-${BASH_SOURCE[0]}}:${BASH_LINENO[0]} in ${FUNCNAME[1]:-main}" 99' ERR

print_help() {
    cat <<'USAGE'
Publish site to the specified output directory
Usage: publish-site [-c|--clean] [-h|--help] [--yes] <source-directory> <output-directory>

Arguments:
    <source-directory>: Directory containing the site source files
    <output-directory>: Directory where the site will be published
    -c, --clean: Clean the output directory before publishing, default is off
    --yes: Assume "yes" for clean confirmation prompts
    -h, --help: Show this help message and exit

Examples:
    publish-site ./site ./public
    publish-site --clean ./site ./public

Dependencies:
    - get-files-to-publish
    - extract-links
    - rsync
    - realpath
    - Bash version 4.3 or higher

Error codes:
    1: Invalid command line arguments
    2: Missing or invalid source or output directory argument
    3: Cleaning errors
    4: Failed to copy files
    5: Dependency issues
    99: Unexpected error
USAGE
}

_positionals=()
_arg_clean="off"
_arg_yes="off"
_arg_source_directory=""
_arg_output_directory=""
_src=""
_out=""

check_dependencies() {
    command -v get-files-to-publish &>/dev/null || \
        die "get-files-to-publish command not found. Please install it and ensure it's in your PATH." 5
    command -v extract-links &>/dev/null || \
        die "extract-links command not found. Please install it and ensure it's in your PATH." 5
    command -v rsync &>/dev/null || \
        die "rsync command not found. Please install it and ensure it's in your PATH." 5
    command -v realpath &>/dev/null || \
        die "realpath command not found. Please install it and ensure it's in your PATH." 5
    if ! (( BASH_VERSINFO[0] > 4 || (BASH_VERSINFO[0] >= 4 && BASH_VERSINFO[1] >= 3) )); then
        die "Bash version 4.3 or higher is required. Current version is ${BASH_VERSION}." 5
    fi
}

parse_commandline() {
    _positionals_count=0
    local _key
    while [[ $# -gt 0 ]]; do
        _key="$1"
        case "$_key" in
        -c | --clean)
            _arg_clean="on"
            shift
            ;;
        -h | --help)
            print_help
            exit 0
            ;;
        --yes)
            _arg_yes="on"
            shift
            ;;
        --) # end argument parsing
            shift
            while [[ $# -gt 0 ]]; do
                _positionals+=("$1")
                shift
            done
            ;;
        -*) # unknown option
            _PRINT_HELP=yes die "Unknown option: '$_key'" 1
            ;;
        *) # positional argument
            _positionals+=("$1")
            shift
            ;;
        esac
    done

    _positionals_count="${#_positionals[@]}"
    if [[ "${_positionals_count}" -lt 2 ]]; then
        die "Not enough positional arguments: expected 2, got ${_positionals_count}" 1
    fi
    if [[ "${_positionals_count}" -gt 2 ]]; then
        die "Too many positional arguments: expected at most 2, got ${_positionals_count}" 1
    fi

    _arg_source_directory="${_positionals[0]}"
    _arg_output_directory="${_positionals[1]}"
}

validate_arguments() {
    if [[ -z "$_arg_source_directory" || -z "$_arg_output_directory" ]]; then
        die "Both source and output directories must be specified." 2
    fi

    if [[ ! -d "$_arg_source_directory" ]]; then
        die "Source directory '$_arg_source_directory' does not exist or is not a directory." 2
    fi

    if [[ ! -d "$_arg_output_directory" ]]; then
        mkdir -p -- "$_arg_output_directory" || die "Output directory '$_arg_output_directory' does not exist and cannot be created." 2
    fi

    # Internal checks
    case "$_arg_clean" in
        on | off) ;;
        *) die "Internal error: Invalid value for --clean: '$_arg_clean'. Allowed values are 'on' or 'off'." 1 ;;
    esac

    case "$_arg_yes" in
        on | off) ;;
        *) die "Internal error: Invalid value for --yes: '$_arg_yes'. Allowed values are 'on' or 'off'." 1 ;;
    esac
}

resolve_directories() {
    _src="$(realpath "$_arg_source_directory")" || die "Cannot resolve source." 2
    _out="$(realpath "$_arg_output_directory")" || die "Cannot resolve output." 2
}

# -- publish site --
clean_output_directory() {
    if ! is_on "$_arg_clean"; then
        return 0
    fi

    local _home
    _home="$(realpath "$HOME")"
    # Security check to prevent accidental deletion of important directories
    case "$_out" in
        /|""|"."|".."|"/root"|"/home"|"/usr"|"/etc"|"/var"|"$_home"|"$_home/."|"$_home/..")
        die "Refusing to clean output directory '$_out' for safety reasons." 3
        ;;
    esac
    if mountpoint -q "$_out"; then
        die "Refusing to clean output directory '$_out' because it is a mount point." 3
    fi

    # Check if the output directory is the same as the source directory
    if [[ "$_out" == "$_src" ]]; then
        die "Output directory '$_out' cannot be the same as the source directory '$_src'." 3
    fi

    # Check if the output directory is a parent of the source directory
    if [[ "$_src" == "$_out"/* ]]; then
        die "Output directory '$_out' cannot be a parent of the source directory '$_src'." 3
    fi
    if [[ "$_out" == "$_src"/* ]]; then
        die "Output directory '$_out' cannot be a subdirectory of the source directory '$_src'." 3
    fi

    if [[ -d "$_out" ]]; then
        if [[ ! -w "$_out" ]]; then
            die "Output directory '$_out' is not writable." 3
        fi

        # Ask for confirmation
        if [[ "$_arg_yes" != "on" ]]; then
            if [[ ! -t 0 ]]; then die "Non-interactive shell: pass --yes to clean." 3; fi
            read -r -p "Are you sure you want to clean '$_out' before publishing? [y/N] " _reply
            if [[ ! "$_reply" =~ ^[Yy]$ ]]; then
                die "Aborted by user." 3
            fi
        fi

        log "Cleaning output directory '$_out'..."
        # Clean the output content and preserve the directory itself for safety
        # shellcheck disable=SC2115 # (safe because of previous checks)
        rm -rf -- "$_out"/* "$_out"/.[!.]* "$_out"/..?* 2>/dev/null || true
    else
        mkdir -p -- "$_out" || die "Failed to create output directory '$_out'." 3
    fi
}

# Convert absolute paths to relative paths based on source directory
# Arguments:
#   - array to fill with relative file paths
#   - list of file paths (absolute or source-relative)
# Note: this assumes file paths are either source-relative or absolute, empty paths are ignored, duplicates are removed
# Exits with error if a file is outside the source directory
get_clean_relative_path_list() {
    local -n _relative_files_ref="${1:?Internal error: Missing argument to get_clean_relative_path_list()}"
    shift
    local _fail_on_invalid="${1:-off}"
    shift

    local -A _seen=()
    local _file _relative
    for _file in "$@"; do
        if [[ -z "$_file" ]]; then
            continue # skip empty
        fi

        if [[ "$_file" != /* ]]; then
            _file="$(realpath "$_src/${_file#./}")" || continue
        else
            _file="$(realpath "$_file")" || continue
        fi

        if [[ "$_file" != "$_src/"* ]]; then
            if is_on "${_FAIL_ON_INVALID:-off}"; then
                die "Found invalid file path '$_file' (outside source directory)." 4
            fi
            log_warn "Skipping file '$_file' outside source directory."
            continue # skip files outside source directory
        fi
        _relative="${_file#"$_src"/}" # make relative to source

        if [[ -n "${_seen["$_relative"]+_}" ]]; then
            continue # skip duplicates
        fi

        _seen["$_relative"]=1
        _relative_files_ref+=("$_relative")
    done
}

# Get list of files to copy, including images linked in the files
# Arguments: array to fill with file paths (relative to source directory)
# Exits with error if a file is outside the source directory
get_files_and_images_to_copy() {
    local -n _files_to_copy_ref="${1?Internal error: Missing argument to get_files_and_images_to_copy()}"

    local -a _files_to_publish=()
    if ! readarray -d '' -t _files_to_publish < <(get-files-to-publish --print0 --only-published --missing-alias "warn" "$_src"); then
        die "Failed to get files to publish." 4
    fi

    if [[ "${#_files_to_publish[@]}" -eq 0 ]]; then
        return 0
    fi

    get_clean_relative_path_list _files_to_copy_ref "on" "${_files_to_publish[@]}"

    local -a _images_to_publish=()
    for _file in "${_files_to_publish[@]}"; do
        local -a _imgs=()
        if ! readarray -d '' -t _imgs < <(extract-links --images --print0 "$_file"); then
            die "Failed to extract image links from file '$_file'." 4
        fi
        if [[ "${#_imgs[@]}" -gt 0 ]]; then
            _images_to_publish+=("${_imgs[@]}")
        fi
    done
    get_clean_relative_path_list _files_to_copy_ref "on" "${_images_to_publish[@]}"
}

# Check for dead internal links in the files to be published
# Arguments: list of file paths (relative to source directory)
# Outputs: warnings for dead links
# Exits with error if a link points outside the source directory
check_dead_links() {
    local -a _files_to_copy=( "$@" )

    local -A _file_set=()
    for _file in "${_files_to_copy[@]}"; do
        _file_set["$_file"]=1
    done

    local _file
    for _file in "${_files_to_copy[@]}"; do
        local -a _internal_links=()
        local _abs_file="$_src/$_file"
        readarray -d '' -t _internal_links < <(extract-links --internal --images --print0 "$_abs_file" || true)
        get_clean_relative_path_list _internal_links "no" "${_internal_links[@]}" || true

        local _link _target_src
        for _link in "${_internal_links[@]}"; do
            if [[ -z "${_file_set["$_link"]+_}" ]]; then
                log_warn "Internal link '$_link' in file '$_file' does not point to a published file."
            fi
        done
    done
}

copy_files() {
    local -a _relative_files=( "$@" )

    # Build NUL-separated list file for rsync
    local _list_file
    _list_file=$(mktemp) || die "Failed to create temporary file." 4
    trap 'rm -f -- '"$_list_file" EXIT

    {
        printf '%s\0' "${_relative_files[@]}"
    } > "$_list_file"

    log "Copying ${#_relative_files[@]} files to '$_out' with rsync..."
    if ! rsync -a --files-from="$_list_file" --from0 "$_src"/ "$_out"/; then
        die "Failed to copy files to '$_out'." 4
    fi
}

main() {
    check_dependencies
    parse_commandline "$@"
    validate_arguments
    resolve_directories
    clean_output_directory

    local -a _files_to_copy=()
    get_files_and_images_to_copy _files_to_copy

    if [[ "${#_files_to_copy[@]}" -eq 0 ]]; then
        log "No files to publish."
        exit 0
    fi

    check_dead_links "${_files_to_copy[@]}"
    copy_files "${_files_to_copy[@]}"
}
main "$@"
