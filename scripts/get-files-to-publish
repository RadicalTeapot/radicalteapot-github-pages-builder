#! /usr/bin/env bash
set -eEuo pipefail

# Arguments parsing automatically generated by Argbash (https://argbash.dev)

die() {
    local _ret="${2:-1}"
    [[ "${_PRINT_HELP:-no}" == "yes" ]] && print_help >&2
    printf '%s\n' "$1" >&2
    exit "$_ret"
}

trap 'die "Error (exit $?): ${BASH_SOURCE[0]}:${LINENO[0]} in ${FUNCNAME[1]-main}" $?' ERR

begins_with_short_option() {
    case "${1:0:1}" in
    [pmh]) return 0 ;;
    *) return 1 ;;
    esac
}

validate_missing_alias() {
    case "$1" in
    ignore | warn | skip-file | error)
        ;;
    *)
        die "Invalid value for --missing-alias: '$1'. Must be one of: 'ignore', 'warn', 'skip-file', 'error'." 1
        ;;
    esac
}

print_help() {
    cat <<'USAGE'
Output publishable markdown files in given directory
Usage: get-files-to-publish [-p|--(no-)only-published] [-m|--missing-alias <arg>] [-h|--help] <directory>

Arguments:
    <directory>: Directory containing the markdown files
    -p, --only-published, --no-only-published: Output only files with a 'publish: true' option in their front-matter (off by default)
    -m, --missing-alias: Check for 'aliases' option if 'slug' or 'url' is set in file front-matter ('ignore', 'warn', 'skip-file' or 'error'. Default: 'ignore')
    -h, --help: Prints help

Examples:
    get-files-to-publish ./content/posts
    get-files-to-publish -p ./content/posts
    get-files-to-publish --only-published --missing-alias warn ./content/posts

Error codes:
    1: Invalid command line arguments
    2: frontmatter-parser command not found
    4: Invalid or missing directory argument
    5: Missing or invalid aliases in front-matter
USAGE
}

# DEFAULTS INITIALIZATION
_positionals=()
_arg_only_published="off"
_arg_missing_alias="ignore"
_arg_directory=""
_markdown_extensions=("md")

parse_commandline() {
    _positionals_count=0
    local _key
    while [[ $# -gt 0 ]]; do
        _key="$1"
        case "$_key" in
        -p | --no-only-published | --only-published)
            _arg_only_published="on"
            [[ "${1:0:5}" = "--no-" ]] && _arg_only_published="off"
            ;;
        -p*)
            _arg_only_published="on"
            _next="${_key##-p}"
            if test -n "$_next" -a "$_next" != "$_key"; then
                { begins_with_short_option "$_next" && shift && set -- "-p" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
            fi
            ;;
        -m | --missing-alias)
            [[ $# -lt 2 ]] && die "Missing value for the optional argument '$_key'." 1
            _arg_missing_alias="$2"
            validate_missing_alias "$_arg_missing_alias"
            shift
            ;;
        --missing-alias=*)
            _arg_missing_alias="${_key##--missing-alias=}"
            validate_missing_alias "$_arg_missing_alias"
            ;;
        -m*)
            _arg_missing_alias="${_key##-m}"
            validate_missing_alias "$_arg_missing_alias"
            ;;
        -h | --help)
            print_help
            exit 0
            ;;
        -h*)
            print_help
            exit 0
            ;;
        *)
            _last_positional="$1"
            _positionals+=("$_last_positional")
            _positionals_count=$((_positionals_count + 1))
            ;;
        esac
        shift
    done
}

handle_passed_args_count() {
    local _required_args_string="'directory'"
    [[ "${_positionals_count}" -ge 1 ]] || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
    [[ "${_positionals_count}" -le 1 ]] || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}

validate_frontmatter_parser_command_exists() {
    if ! command -v frontmatter-parser &>/dev/null; then
        die "Error: Could not find frontmatter-parser in PATH." 2
    fi
}

assign_positional_args() {
    # Note: this is where _arg_directory gets filled (given to _positional_names and filled by eval in the loop)
    local _positional_name _shift_for=$1
    _positional_names="_arg_directory " # space at the end is intentional

    shift "$_shift_for"
    for _positional_name in ${_positional_names}; do
        [[ $# -gt 0 ]] || break
        eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
        shift
    done
}

validate_arg_directory() {
    [[ -z "$_arg_directory" ]] && die "Error: No source directory specified." 4
    if [[ ! -d "$_arg_directory" ]]; then
        die "Error: Source directory '$_arg_directory' does not exist." 4
    fi
}

should_be_published() {
    local _file="$1"
    if [[ "$_arg_only_published" == "off" ]]; then
        return 0
    elif _value=$(frontmatter-parser "$_file" --parameter "publish" 2>/dev/null); then
        [[ "${_value#*[$'\t']}" == "true" ]] && return 0
    fi
    return 1
}

get_aliases() {
    local _file="$1" _aliases
    _aliases=$(frontmatter-parser "$_file" --parameter "aliases" 2>/dev/null) || return 1
    _aliases=${_aliases#*$'\t'}                          # drop leading key/sep if present
    _aliases=${_aliases//\"/}                            # drop quotes
    tr ',' '\n' <<<"$_aliases" | sed '/^[[:space:]]*$/d' # Replace commas with newlines and remove empty lines
}

check_valid_aliases() {
    local _file="$1"
    local _slug _url _aliases _aliases_array _relative_file_path

    if [[ "$_arg_missing_alias" == "ignore" ]]; then
        return 0
    fi

    _slug=$(frontmatter-parser "$_file" --parameter "slug" 2>/dev/null || echo "")
    _url=$(frontmatter-parser "$_file" --parameter "url" 2>/dev/null || echo "")

    if [[ -n "$_slug" || -n "$_url" ]]; then
        if ! _aliases=$(get_aliases "$_file"); then
            case "$_arg_missing_alias" in
            warn)
                echo "Warning: File '$_file' has 'slug' or 'url' set but no 'aliases' option." >&2
                return 0
                ;;
            skip-file)
                echo "Skipping file '$_file' because it has 'slug' or 'url' set but no 'aliases' option." >&2
                return 1
                ;;
            error)
                die "Error: File '$_file' has 'slug' or 'url' set but no 'aliases' option." 5
                ;;
            esac
        fi

        # Check if file is in aliases
        _relative_file_path="${_file#"$_arg_directory"}"  # Keep the leading slash if any as it has meaning in aliases
        _relative_file_path="${_relative_file_path%*.md}" # TODO: handle other markdown extensions (use _markdown_extensions array)
        local _found_alias="false"
        while IFS= read -r _alias; do
            if [[ "$_alias" == "$_relative_file_path" ]]; then
                _found_alias="true"
                break
            fi
        done <<<"$_aliases"

        if [[ "$_found_alias" == "false" ]]; then
            case "$_arg_missing_alias" in
            warn)
                echo "Warning: File '$_file' has 'slug' or 'url' set but its filename '$_relative_file_path' is not in 'aliases'." >&2
                ;;
            skip-file)
                echo "Skipping file '$_file' because it has 'slug' or 'url' set but its filename '$_relative_file_path' is not in 'aliases'." >&2
                return 1
                ;;
            error)
                die "Error: File '$_file' has 'slug' or 'url' set but its filename '$_relative_file_path' is not in 'aliases'." 5
                ;;
            esac
        fi
    fi
}

main() {
    # Find all markdown files in the specified directory
    local _md_files=()
    mapfile -t -d '' _md_files < <(
        find "$_arg_directory" -type f -name "*.${_markdown_extensions[0]}" -print0
    )

    local _files_to_publish=()
    for _file in "${_md_files[@]}"; do
        if should_be_published "$_file" && check_valid_aliases "$_file"; then
            _files_to_publish+=("$(realpath "$_file")")
        fi
    done

    printf '%s\n' "${_files_to_publish[@]}"
}

# Validation and parsing
validate_frontmatter_parser_command_exists
parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"
validate_arg_directory

# Run the script
main
